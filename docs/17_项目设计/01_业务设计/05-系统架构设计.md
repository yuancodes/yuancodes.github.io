---
title: 05-系统架构设计
date: 2020-12-08 16:00:56
tags:
- 架构设计
- 系统设计
categories: 
- 17_项目设计
- 01_业务设计
---



<p><strong>基本概念</strong></p>
<p>系统可用性（Availability） ：</p>
<blockquote>
<p>高可用的系统，故障时间少，止损快，在任何给定的时刻都可以工作。</p>
<p>一般公司对系统可用性的要求在99.9%——99.99%之间，即：宕机时长在50分钟——500分钟之间。</p>
</blockquote>
<p>系统可靠性（Reliability）：</p>
<blockquote>
<p>高可靠的系统，故障次数少，频率低，在较长的时间内无故障地持续运行。</p>
</blockquote>
<p>系统稳定性（Stability）：</p>
<blockquote>
<p>在系统可靠性和可用性之上，即降低故障频次和提升止损速度的情况下，要求系统的性能稳定，不要时快时慢。</p>
</blockquote>
<p>系统可用性和系统可靠性的区别:</p>
<blockquote>
<p>如果系统在每小时崩溃一毫秒，它的可用性就超过99.9999%，但它还是高度不可靠的。</p>
<p>如果系统从来不崩溃，但每年的圣诞节前后停机两周，它是高度可靠的，但是系统的可用性只有96%。</p>
</blockquote>
<p>故障时长:</p>
<blockquote>
<p>总故障时长 &#x3D; 故障发现时长 + 故障定位时长 + 故障解决时长</p>
</blockquote>
<p><strong>高并发解决方案</strong></p>
<blockquote>
<p>横向扩容(堆机器)</p>
<p>引入缓存</p>
<p>引入ES(高并发的查询场景中，包含了一些多维复杂场景查询)</p>
<p>分库分表</p>
<p>MQ消峰</p>
<p>单元化:</p>
<ul>
<li>将用户的请求流量，按照特定的规则，路由到不同的单元内。</li>
<li>同时在单元内做到整个业务逻辑的闭环，起到分散系统高并发压力，快速支持扩容，快速切换容灾的作用。</li>
</ul>
</blockquote>
<p><strong>如何搭建一个新系统</strong></p>
<blockquote>
<p>架构设计按照实施过程可分为工程架构，业务架构，部署架构等多个维度。</p>
<p>一个好的系统架构标准应该具备可扩展、可维护、可靠性、安全性和高性能等特点。</p>
</blockquote>
<p>价值为先：</p>
<blockquote>
<p>技术容易陷入的两个误区：</p>
<ul>
<li><p>来者不拒：产品经理提的需求，都是有道理的，全都负责完成。</p>
</li>
<li><p>技术驱动：这种技术实现特别巧妙，让产品特性适配于技术实现。</p>
</li>
</ul>
<p>这两类误区，很容易让研发对产品价值的理解形成偏差，容易对后续的技术迭代产生颠覆性的影响。</p>
<p>在方案出现歧义时，需要站在产品（商业）价值的视角审视方案并作出决策。</p>
<p>站在产品（商业）价值维度：</p>
<ul>
<li>能够让协作各方站在平等的视角看问题，不仅能够容易达成共识，也能更好地为业务演进和技术迭代做好规划。</li>
</ul>
</blockquote>
<p>架构设计:</p>
<blockquote>
<p>架构模式描述了软件系统中各个组件之间的关系、职责和交互方式，从而为软件设计提供了一种规范和约束，进而提高软件生产效率。</p>
<p>主要体现在以下两个方面：</p>
<ul>
<li>帮助开发人员更好地组织和设计软件系统。</li>
<li>促进团队之间的协作和沟通，使得团队成员更容易理解和分工。</li>
</ul>
</blockquote>
<p>工程框架：</p>
<blockquote>
<p>新系统是从搭建项目的工程基础框架开始，包括目录结构、配置文件、代码模板等工程约束，主要用来规范项目结构、职责边界和代码风格，从而提高代码质量和可维护性。</p>
<p>具体包括以下几个方面：</p>
<ul>
<li>约定了各个模块的依赖关系和交互方式。</li>
<li>规范接口交互协议。</li>
<li>统一异常编码、捕获和处理。</li>
<li>规范日志打印格式。</li>
<li>其它公共规范约束。</li>
</ul>
</blockquote>
<p>技术选型：</p>
<blockquote>
<p>工程架构的搭建除了基础框架外，还有就是各类基础中间件的选择，也就是常说的技术选型。</p>
<p>业务需求:</p>
<ul>
<li>了解业务需求，明确系统的功能、性能、安全以及未来的扩展需求。</li>
</ul>
<p>技术特性:</p>
<ul>
<li>评估不同技术的特性，包括可用性、性能、安全性、可扩展性、可维护性等方面。</li>
</ul>
<p>社区支持:</p>
<ul>
<li>考虑技术的社区支持程度，包括是否有活跃的社区、是否有大量的文档和教程、是否有成熟的第三方库等。</li>
</ul>
<p>团队技能:</p>
<ul>
<li>根据团队的技能水平选择合适的技术，避免使用过于复杂或陌生的技术。</li>
<li>否则后期的维护成本和迭代效率将成为一个大的难题。</li>
</ul>
<p>成本效益:</p>
<ul>
<li>评估不同技术的成本效益，包括开发成本、运维成本、许可证费用等方面。<ul>
<li>如果有成熟的开源插件可用，应该尽量使用它们，而不是重新发明轮子。</li>
<li>对于其他团队已经完成的任务，需要考虑是否可以复用。</li>
</ul>
</li>
</ul>
<p>风险评估：</p>
<ul>
<li>评估不同技术的风险，包括技术成熟度、安全漏洞、依赖关系等方面。</li>
</ul>
</blockquote>
<p>规范共识：</p>
<blockquote>
<p>确保团队成员之间的沟通和理解达成一致。</p>
<p>通过制定规范和流程，可以减少重复工作和错误，避免冲突和误解，这有利于提高研发效率和质量。</p>
<ul>
<li>制定数据分层，异常管理，日志管理，监控管理的规范。</li>
</ul>
</blockquote>
<p><strong>如何构建一个高可用的系统</strong></p>
<p>减少故障次数：</p>
<blockquote>
<p>限流，防刷，超时设置，熔断，降级</p>
</blockquote>
<p>系统巡检:</p>
<blockquote>
<p>系统巡检一般是应用在代码上线后，或是系统业务高峰期以前进行的，旨在提前发现并处理系统中的潜在问题。</p>
<p>业务高峰期以前进行，适合于业务波峰和波谷比较明显的情况。</p>
<p>巡检内容包括：</p>
<ul>
<li><p>应用、数据库、中间件服务器的硬件指标，比如：负载、CPU、磁盘、网络、内存、JVM等。</p>
</li>
<li><p>系统QPS、TPS、接口响应时间、错误率等。</p>
</li>
<li><p>是否有新增的慢查SQL，以及SQL执行时间和次数等，这点尤为关键。</p>
</li>
</ul>
</blockquote>
<p>故障复盘:</p>
<blockquote>
<p>围绕故障本身去进行深挖，用追根究底的精神去发掘问题的本质，而不是仅仅停留在:</p>
<ul>
<li>开发的时候没有想到、测试的时候没有覆盖到、巡检的时候遗漏了等层面。</li>
</ul>
<p>根据重要紧急、重要不紧急两个维度，制定短期和中期TODO。</p>
<p>务必明确执行人以及完成时间，并持续地监督跟进，直到所有的TODO全部完成。</p>
<p>另外，TODO必须是可落地的，而不是：</p>
<ul>
<li>下次开发的时候多思考、下次测试的时候多重视、下次巡检的时候多注意之类的口号流。</li>
</ul>
<p>故障复盘不但是通过流程规范和技术策略，保证在以后的开发迭代中，系统不再引入增量的同类问题。</p>
<p>也是一种由点及面地去清理现有系统中的存量问题。</p>
</blockquote>
<p>监控告警:</p>
<blockquote>
<p>系统监控可以分为三层：基础监控、服务监控和业务监控。</p>
</blockquote>
<p>上线规范：</p>
<blockquote>
<p>80%的故障都是由于发布上线导致的，上线规范旨在可跳过 故障定位 环节，快速解决由本次上线而导致的系统故障。</p>
</blockquote>
<p>无脑预案：</p>
<blockquote>
<p>在整个过程中，只需要按照应急预案中的步骤执行，而不需要进行思考。</p>
<p>因为思考就会产生选择，而选择取舍是最耗费时间的事情。</p>
</blockquote>
<p>故障演练：</p>
<blockquote>
<p>旨在模拟生产环境中可能出现的故障，测试系统或应用在面对故障时的反应和响应能力。</p>
</blockquote>
<p><strong>系统架构的合理性</strong></p>
<p>从研发角度思考：</p>
<blockquote>
<p>系统的上下文清晰：</p>
<ul>
<li>明确知道和周围系统的调用关系，数据同步机制。</li>
</ul>
<p>应用架构设计简单：</p>
<ul>
<li>架构分层合理，功能定位清晰，不会出现功能边界之外事情。</li>
</ul>
<p>应用拆分合理：</p>
<ul>
<li>系统内的应用粒度在一个合理的范围内，应用间调用链路不应过长。</li>
</ul>
</blockquote>
<p>从业务角度来评估：</p>
<blockquote>
<p>能解决当下业务需求和问题。</p>
<p>高效完成业务需求: </p>
<ul>
<li>能以优雅且可复用的方式解决当下所有业务问题。</li>
</ul>
<p>前瞻性设计: </p>
<ul>
<li>能在未来一段时间都能以第2种方式满足业务，从而不会每次当业务进行演变时，导致架构翻天覆地的变化。</li>
</ul>
</blockquote>
<p><strong>架构师的核心能力抽象能力</strong></p>
<blockquote>
<p>抽象能力就是一种化繁为简的能力。</p>
<ul>
<li>就是把一种复杂的事情变得简单的能力。</li>
</ul>
<p>有三种方法：</p>
<ul>
<li><p>归纳法找共性，从多个问题中找到共同的问题提炼通用解决方案，去其糟粕取其精华。</p>
</li>
<li><p>演绎法找关系，从多个问题中找关系，把多个问题串成一个问题，系统化解决问题。</p>
</li>
<li><p>归纳法找特性：化繁为简需要不断的思考，不断的看清一件事的本质，这个事的解决方案越容易。</p>
</li>
</ul>
</blockquote>
<p>通过归纳法找共性:</p>
<blockquote>
<p>﻿通过归纳法找共性有两种方法，分别是找需求的共性和找信息的共性。</p>
<p>找需求的共性：</p>
<ul>
<li>从一类需求中找到共性问题，找到最大交集然后求解。<ul>
<li>收到一堆需求，能分析出共同的需求是什么。</li>
</ul>
</li>
</ul>
<p>找信息的共性:</p>
<ul>
<li>领域建模就是一种找信息共性的方法。</li>
<li>领域建模首先就是要区分需求里哪些是变化的哪些是不变，把这个领域不变的信息沉淀成领域模型，基于领域模型做架构。</li>
</ul>
</blockquote>
<p>通过演绎法找关系：</p>
<blockquote>
<p>找内部关系:</p>
<ul>
<li>内部关系就是找到业务的生命周期和系统内部的主链路。</li>
</ul>
<p>找外部关系：</p>
<ul>
<li>梳理清楚架构的边界，什么做什么不做，什么是本领域的核心服务，这些服务提供给谁使用，需要依赖其他领域的核心服务有哪些。</li>
</ul>
</blockquote>
<p>通过归纳法找特性：</p>
<blockquote>
<p>﻿找特性是通过归纳法先找两个业务的共性。</p>
<ul>
<li>举一个例子，如果要精通JAVA要学习的内容会非常多，可能花很多时间学习也不一定能精通JAVA语言，投入产出比不高。</li>
</ul>
<p>但是如果想化繁为简就必须先找到JAVA的特性，针对特性进行深入学习。</p>
<ul>
<li>JAVA的两项特性技术是<strong>垃圾回收机制</strong>和<strong>多线程框架</strong>，剩下的就和其他语言的特性差不多。</li>
</ul>
<p>特性和找共性存在矛盾，所以在这个过程中需要做取舍：</p>
<ul>
<li>关键是面对当下的业务，判断什么当下或者未来最重要的事是什么。</li>
<li>可能满足场景个性化需求虽然增加研发成本，但是能给业务带来技术壁垒。</li>
<li>或者有没有一种方式能既满足共性需求又能满足部分个性化需求。</li>
</ul>
</blockquote>
<p><strong>幂等问题</strong></p>
<blockquote>
<p>幂等指多次调用对系统的产生的影响是一样的。</p>
<ul>
<li>即对资源的作用是一样的，但是返回值允许不同。</li>
</ul>
</blockquote>
<p>Token机制:</p>
![image-20241008160843294](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20241008160844.png)



<blockquote>
<p>服务端提供了发送token的接口。</p>
<ul>
<li>在执行业务前，先去获取token，服务器会把token保存到redis中。</li>
</ul>
<p>调用业务接口请求时，把token携带过去，一般放在请求头部。</p>
<p>服务器判断token是否存在redis中，存在表示第一次请求，可以继续执行业务。</p>
<ul>
<li>执行业务完成后，最后需要把redis中的token删除。</li>
</ul>
<p>如果判断token不存在redis中，就表示是重复操作，直接返回重复标记给client。</p>
<ul>
<li>这样就保证了业务代码，不被重复执行。</li>
</ul>
</blockquote>
<p>乐观锁机制：</p>
<pre><code class="sql">update user set point = point + 20, version = version + 1 where userid=1 and version=1
</code></pre>
<p>唯一主键机制:</p>
<blockquote>
<p>利用数据库的主键唯一约束的特性，解决了在<code>insert</code>场景时幂等问题。</p>
<p>但主键的要求不是自增的主键，这样就需要业务生成全局唯一的主键。</p>
</blockquote>
<p>去重表机制:</p>
![image-20241008160931090](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20241008160932.png)



<blockquote>
<p>这个去重表中只要一个字段就行，设置唯一主键约束。</p>
<ul>
<li>当然根据业务自行添加其他字段。</li>
</ul>
<p>把唯一主键插入去重表，再进行业务操作，且他们在同一个事务中。</p>
<p>这个保证了重复请求时，因为去重表有唯一约束，导致请求失败，避免了<strong>幂等</strong>问题。</p>
<p>去重表和业务表应该在同一库中，这样就保证了在同一个事务。</p>
<ul>
<li><p>即使业务操作失败了，也会把去重表的数据回滚。</p>
</li>
<li><p>这个很好的保证了数据一致性。</p>
</li>
</ul>
<p>这个方案比较常用去重表是跟业务无关的，很多业务可以共用同一个<strong>去重表</strong>。</p>
<ul>
<li>只要规划好唯一主键就行了。</li>
</ul>
</blockquote>
<p><strong>本地缓存一致性刷新</strong></p>
<blockquote>
<p>服务是多节点部署的，要保证是本地缓存一致性的，就要短时间内操作所有服务。</p>
<p>方案1-MQ广播消息</p>
<p>方案2-Zookeeper Watcher机制</p>
<p>方案3-RPC框架广播调用(如Dubbo广播调用方式)</p>
<p>方案4-分布式任务调度的广播执行任务</p>
</blockquote>

<table>
<thead>
<tr>
<th>方案</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>MQ广播消息</td>
<td>有消息积压、消息顺序的问题</td>
</tr>
<tr>
<td>Zookeeper Watcher机制</td>
<td>Zookeeper本身适合读多写少的场景</td>
</tr>
<tr>
<td>RPC框架广播调用(如Dubbo广播调用方式)</td>
<td>循环调用所有的实例，所有要考虑实例过多的情况</td>
</tr>
<tr>
<td>分布式任务调度的广播执行任务</td>
<td>便于定时发布</td>
</tr>
</tbody></table>

