---
title: 00-面试题杂项整理（前端）
date: 2017-5-3 00:09:33
tags:
- 面试题
- 前端
categories: 
- 20_面试问题
- 01_技术问题
---



## HTML

```js
1. HTML5 结构语义化：
	用正确的标签做正确的事情。p段落、h标题、aside边栏、main主要内容等...
	对开发者：便于维护、较好的呈现内容结构和代码结构、易于阅读；
	对浏览器：有利于SEO，搜索引擎爬虫依赖于标签、方便其他设备解析、提高可访问性
2. HTML5 新特性：
	新增：主要是关于图像、位置、存储、多任务等功能的增加
	    媒体播放的 video/audio 元素
	    本地存储 localStorage 长期存储(浏览器关闭不消失) / sessionStorage 数据浏览器关闭删除
	    语义化更好的内容元素(article,footer,header,nav,section)
	    表单控件(calendar、date、time、email、url、search)
	    新的技术(webworker,websocket,geolocation)
    移除：纯表现的元素(basefont, big, center, font, s, strike, tt, u)、可用性有负面影响的元素(frame, frameset, noframes)
3. cookies, sessionStorage, localStorage 区别：
	cookies(最大4k): 标识用户身份，存储在用户本地终端(通常经过加密)，始终自动同源http请求中携带
	sessionStorage(5M或更大): 数据在当前浏览器窗口关闭后自动删除
	localStorage(5M或更大): 持久化存储数据，浏览器关闭不会丢失除非主动删除
4. 浏览器的渲染机制的步骤：
	处理HTML并构建DOM树 → 处理CSS构建CSSOM树 → 将DOM与CSSOM合并为一个渲染树 → 布局并计算每个节点的位置 → 调用GPU绘制合成图层并显示在屏幕上
	注意：CSSOM树会阻塞渲染，因此CSS选择器要尽量层级扁平，减少过度层叠；JS文件要按需加载，不在首页去全部加载
5. 重绘（Repaint）和回流（Reflow）
	重绘：节点需要更改【外观】而不影响布局的，如改变color就是重绘
	回流：【布局或者几何属性】改变就是回流
	减少重绘和回流：
	① 批量修改 DOM
	② 复杂动画效果，使用绝对定位使其脱离文档流
	③ CSS3硬件加速(GPU加速) transform/opacity/filters 这些动画不会引起回流重绘
6. data:属性的用法，有何优势？
    data-* 的值的获取和设置，2种方法：
	① [无兼容性问题，不优雅]getAttribute() 获取 data-属性值；setAttribute() 设置 data-属性值
	② [有兼容性问题，更优雅]HTML5新方法：如 data-jerry, dataset.jerry 获取data-jerry属性值； dataset.jerry="张三" 设置 data-jerry 属性值
	优势：自定义的数据可以让页面拥有更好的交互体验
```



## CSS

```js
1. display:none; 与 visibility:hidden; 的区别
    相同：都可以让元素不可见
    区别：
      1)display:none 元素完全从渲染树中消失，渲染时不占空间；visibility:hidden 不会让元素从渲染树消失，渲染时占空间，内容不可见
      2)修改常规常规流中的元素 display 会造成【文档重排】、修改 visibility 属性只会造成本元素的【重绘】
2. 外边距折叠
    相邻的两个或多个 margin 会合并成一个 margin，叫做外边距折叠。规则如下：
    ①两个或多个相邻的普通流中的【块元素垂直方向】上 margin 会折叠
    ②【浮动】元素或【inline-block】元素或【绝对定位】元素 margin 不会和垂直方向上的其他元素 margin 折叠
    ③创建了块级格式上下文(BFC)的元素，不会和它的子元素发生margin折叠
3. z-index是什么？position的值什么时候可以触发？
    z-index 设置元素的堆叠顺序。
    注意：z-index 仅能在定位元素上有效，position = relative / absolute / fixed / sticky 时才会触发层级设置。
4. box-sizing 的有效值以及对应的盒模型规则：
    1)box-sizing:content-box; 默认值，宽度和高度分别应用到元素的内容框；在宽度和高度【之外】绘制元素的【内边距和边框】。
    2)box-sizing:border-box; 【内边距和边框】都在已设定宽度和高度【之内】进行绘制。内部元素宽高会被挤压，使我们更容易控制元素宽高。
    3)box-sizing:inherit; 继承父元素的 box-sizing 属性的值。
5. 移动端适配怎么做？
    ①【meta 标签 viewport】（视口适配）
    移动端初始视口大小默认是 980px，为了解决页面缩放体验问题，代码头部会加入一行 viewport 原标签，告诉浏览器视口的宽度为设备的宽度。
    属性含义：
        initial-scale: 第一次进入页面的初始比例
        minimum-scale: 允许缩小最小比例
        maximum-scale: 允许放大最大比例
        user-scalable：允许使用者缩放，1 or 0（yes or no）
    ②【图片适配】
    img { max-width: 100%; } 此时图片会自动缩放，同时图片最大值为自身的100%
    为什么不用 img { width: 100%; } ? 当容器大于图片宽度时，图片会无情的拉伸变形。
    ③【媒体查询】
    自动检测屏幕宽度，然后加载相应的CSS文件或样式，语法 @media screen and (min-width:1200px) { 样式代码 }
    ④【动态 rem 方案】
    rem 和媒体查询配合实现响应式布局。
    	px：像素，屏幕上显示数据的最基本的点，HTML中默认单位；
    	em：相对于【父元素的 font-size】 的百分比大小；
    	rem：相对于【根元素的 font-size】的大小，如
    	    css 中 html{ font-size: 100px; }
    	    js  中动态设置 fontSize，以 iphone6的750px为标准宽度等比缩放设计稿，使用375px进行计算，计算方式
    	    document.documentElement.style.fontSize = document.documentElement.clientWidth / 375 * 100 + 'px';
6. CSS3中的 transform? transition? animation? 区别是什么？
    transform: 静态样式，对元素进行移动translate、缩放scale、旋转rotate、扭曲skew、矩阵变形matrix
    transition: 样式过度，从一种效果改变为另一种效果，复合属性，分别可以设置 CSS属性、过度效果时间、速度曲线、过渡开始的延迟时间
    animation: 动画属性，由 @keyframes 来描述每一帧的样式
    区别：
        1) transform 仅描述元素静态样式，尝尝配合 transition 和 animation 使用
        2) transition 通常和 hover 等事件配合使用，animation 是自发的，立即播放
        3) transition 可与 js 配合使用，js设定要变化的样式，transition 负责动画效果
        4) animation 可设置循环次数
        5) animation 可设置每一帧的样式和时间，transition 只能设置头尾
7. 父元素和子元素的宽高不固定，如何实现水平垂直居中？
    方式1：【定位+位移】父元素相对定位，子元素绝对定位 + left:50% + top: 50% + transform: translate(-50%, -50%) 位移
    方式2：【弹性布局】主轴和侧轴居中，即 display:flex; justify-content:center; align-item:center; 
8. 假设高度默认100px，写出三栏布局、其中左栏、右栏各位300px，中间自适应
    方式1：浮动（盒子1left左浮动、盒子2right右浮动、盒子3center自动填满中间）--必须是这个顺序！
    方式2：绝对定位（盒子1定位left0、盒子3定位right0）
    方式3：弹性布局（盒子1宽度300，盒子3宽度300，盒子2设置flex:1）
9. BFC, 块级格式上下文
    BFC（Block Formatting Context，块级格式上下文）是 CSS 中一种独立的渲染环境 / 布局规则。
    BFC 的元素===“封闭的独立盒子”，盒子内部元素布局都不会影响到外部元素，外部元素也不会干扰盒子内部布局，且盒子内遵循独立的布局规则。
    只要元素满足以下任意一个条件，就会创建 BFC：
        ①根元素（<html>）
        ②浮动元素（float 不为 none，比如 float: left/right）
        ③绝对定位 / 固定定位元素（position: absolute/fixed）
        ④行内块元素（display: inline-block）
        ⑤表格单元格 / 表格标题（display: table-cell/table-caption）
        ⑥溢出元素（overflow 不为 visible，比如 overflow: hidden/auto/scroll【最常用】）
        ⑦弹性 / 网格容器（display: flex/grid）
    应用场景：（触发 BFC 最常用方法，简单无副作用，添加 overflow: hidden）
    	①【清除浮动（解决父元素高度塌陷）】
    	  父元素里子元素设置浮动后，父元素会失去高度（塌陷），无法包裹子元素。【解决】给父元素触发BFC（最常用 overflow: hidden）
    	②【解决垂直方向 margin 重叠问题】
    	  两个相邻的块级元素，垂直方向的 margin 会 “合并”（取最大值，而非相加）。【解决】给其中1个元素包裹一层div触发 BFC 的父元素
    	③【阻止浮动元素覆盖普通元素】
    	  浮动元素会覆盖旁边的普通块级元素，导致布局错乱。【解决】给被覆盖的元素（如浮动的div盖住了 p 标签）p标签触发 BFC
```



## JavaScript

```js
1. JS内置对象：
    数据封装类对象：Object, Array, Boolean, Number, String
    其他对象：Function, Arguments, Math, Date, RegExp, Error
    ES6新增对象：Symbol(标识唯一性的ID), Map, Set, Promises, Proxy, Reflect
2. 如何最小化重绘(repaint)和回流(reflow)？
    ①对元素复杂操作时，先隐藏(display:none)，操作完再显示
    ②创建多个DOM节点时，使用 DocumentFragment 创建完后一次性的加入 document
    ③缓存 Layout 属性值，如 var left=elem.offsetLeft; 这样多次left只产生一次回流
    ④尽量避免用 table 布局
3. JS作用域链？
    全局函数无法查看局部函数的内部细节，局部函数可以查看其上层的函数细节，直至全局细节；
    当前作用域函数没有找到属性或方法，会向上层作用域[[Scoped]]查找，直至全局函数，这就是作用域链。
4. 数据请求？XHR, fetch, jsonp
   XHR: XMLHttpRequest()，  xhr.abort();//取消或终止请求
   fetch: w3c新的标准，fetch().then(res => res.json()).then(res => console.log(res))
   jsonp: 解决跨域，且只有get请求；原理是动态创建 script 标签，请求数据没有限制
5. 跨域和同源策略
    同源：同协议、同域名、同端口 才能进行数据请求和响应交互。非同源就会触发CORS跨域。
    ① JSONP：利用动态创建 script 标签，请求数据没有限制，解决跨域。
    ② CORS：依赖服务端对前端的请求头进行放行，不做限制（Access-Control-Allow-Origin:*）
    ③ 反向代理：前端访问无跨域问题的代理服务器，代理服务器再去访问目标服务器
6. 面向对象
	1)构造函数：通过函数方法创建一个对象，可以 new 一个该对象
	2)原型：Test.prototype.getName = function() {} 缺点是：原型很容易被覆盖而丢失原有的功能
	3)继承：Test.call(this, ...) 或 Test.apply(this, ...) 然后原型继承 Test2.prototype = Test.prototype
	4)原型链：任何一个实例，通过原型链找到它上面的原型，该原型对象中的方法和属性，可以被所有的原型实例共享。
7. 闭包：实际开发中使用到的闭包
	【函数内部返回一个函数】，而这个函数又被外界使用，导致该函数和返回的函数都不会被垃圾回收，此用法称之为闭包。
	使用的多了可能会导致【内存泄露】。
	场景1：【函数防抖】（搜索查询），即 input 绑定一个延迟500ms定时器去延时请求搜索查询来实现防抖，而不是所有输入都请求数据
	场景2：【函数节流】（图表自适应），即 resize 用于 echart 重新渲染图标大小时，拖动窗口超过如1s时，才重新设置 echarts 的 option渲染图标
	场景3：【循环添加事件】（ul li），即 ul li 标签遍历 li 添加事件时，遍历会瞬间执行完，使用闭包可以让每个点击对应每个事件，而不是直接全部执行完毕
8. 数组去重： Array.from(new Set([1, 2, 2, 3, 3, 4]))  //[1,2,3,4]
9. 数组合并：
	①concat    ②[...a, ...b]展开运算符    ③[a, b].flat()扁平化
10. cookie 和 session - 【登陆鉴权如何实现的？】
    cookie: 客户端向服务端登陆的时候，服务端通过响应头去set-cookie，在浏览器注入cookie(可能携带隐私敏感信息) -- 可能会被模拟cookie即模拟登陆
    session: 服务端建立用户信息表和生命周期机制，服务端在客户端登陆时将此信息返回为set-cookie，客户端存储到cookie或localStorage均可
             每次请求携带该验证信息，服务端去验证是否有效或过期
             一般是 cookie 中存 sessionId --或-- localStorage 中存储 token
11. 协商缓存和强缓存的区别
    相同：都是浏览器对静态资源文件的缓存机制
    不同：
    	- 强缓存：客户端直接查看本地的缓存文件是否过期，如果没有过去就直接取用。【不涉及服务端交互】
    	          依靠响应头上的 expires(绝对时间) 和 cache-control(相对时间) 两个值来对比
    	- 协商缓存：客户端去询问服务器对应的文件是否有更新，如果有更新才会重新请求。
    	          依靠 last-modified(最后更新时间) 和 etag(内容变更标识) 来确认文件是否有更新
    【一般做法】在静态文件的 url 如 xxx.js 后面追加了 ?t=时间戳 参数，可以阻止浏览器缓存，每次都可以获取到最新的信息
12. HTTP与HTTPS
    HTTP：明文传输，TCP传输交换3个包，默认端口号 80
    HTTPS：加密传输，TCP传出交换3+9=12个包，默认端口号 443，TLS加密即通过证书对双方进行身份验证
13. 跨域问题解决：
    ①一般线上环境不会有跨域问题，因为前后端都部署在同一台服务器。
    ②本地开发可能会有跨域，比如本地访问测试或开发服务器的接口，基本都是后端设置允许跨域为 * ，有时前端也需要配置脚手架的 devServer 中配置 Proxy
    ③极少的情况下，项目中可能会访问一些第三方api，如定位、天气这些接口，可能会根据接口的情况使用 jsonp 进行跨域处理。
14. 事件循环机制：
    1)所有同步任务在主线程上执行，形成一个【执行栈】
    2)主线程之外，还存在一个【任务队列】，只要一步任务(setInterval, setTimeout, i/o...)有了结果，就在【任务队列】中放置一个事件
    3)一旦执行栈中的所有同步任务执行完毕，系统就会读取【任务队列】，拿到队列的第一个任务，进入执行栈，开始执行
    4)主线程不断重复步骤3)
15. 宏任务 与 微任务
    宏任务：script 全部代码、setTimeout、setInterval、I/O、UI Rendering...
    微任务：Promise、Process.nextTick(Node独有)...
16. HTTP状态码：
    200 OK 正常返回信息 || memory cache 【强缓存】
    201 Created 请求成功并且服务器创建了新资源
    202 Accepted 服务器已接收请求，但尚未处理
    301 Moved Permanently 重定向-请求的网页已永久移动到新位置
    302 Found 重定向-临时性重定向
    304 Not Modified 自动上次请求后，请求的网页未修改过【协商缓存】
    307 Internal Redirect 重定向-内部重定向
    400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次请求
    401 Unauthorized 请求未授权
    403 Forbidden 禁止访问
    404 Not Found 找不到任何与 URI 相匹配的资源
    500 Internal Server Error 服务端错误
    503 Service Unavailable 服务端无法处理的请求，服务不可用
17. 一个页面从输入URL到页面加载显示完成，这个过程都发生了什么？
    ①【域名解析IP】：浏览器查找域名对应的IP地址（DNS查询：浏览器缓存->系统缓存->路由器缓存->ISP DNS缓存->根域名服务器）
    ②【TCP三次握手】：浏览器向web服务器发送一个HTTP请求（TCP三次握手）
    ③【重定向】：服务器301重定向（从 xxx.com 重定向到 www.xxx.com）
    ④【请求】：浏览器跟踪重定向地址，请求另一个带www的网址
    ⑤【处理请求】：服务器处理请求（通过路由读取资源）
    ⑥【响应】：服务器返回一个HTTP响应（抱头中把Content-type 设置为 text/html）
    ⑦【DOM构建】：浏览器进DOM树构建
    ⑧【请求资源】：浏览器发送请求获取嵌在HTML中的资源（如图片、音频、视频、CSS、JS等）
    ⑨【显示页面】：浏览器显示完成页面
    ⑩【异步请求】：浏览器发送异步请求
18. CSRF跨站请求伪造 & XSS脚本注入攻击
    CSRF：①登陆受信任网站A，并在本地生成cookie； ②在不登出A的情况下，访问危险网站B(利用了A网站的漏洞)【因为浏览器会自动携带cookie】
        解决方案：
           1)Token验证(最常用)：前端携带token后端验证token
           2)隐藏token在head请求头中
           3)Referer验证：只接受本站请求，其他拦截掉
    XSS：不需要做任何登陆认证，通过合法的操作，向你的页面注入脚本(如js代码发送你的明文cookie外部)，即盗用cookie/破坏页面插入广告/doss攻击
        解决方案：
           1)编码：对用户输入的数据进行 HTML Entity 编码
           2)过滤：移除用户输入的和事件相关的属性、移除用户输入的style、script、iframe节点
    区别：CSRF是利用网站A本身的漏洞，去请求网站A的api；  XSS是向网站注入js代码，然后执行js代码，篡改网站的内容
```

### 闭包应用

#### ①函数防抖

```js
    <input type="text" id="mytext">
    <script>
        var oInput = document.getElementById('mytext')
        // oInput.oninput = () => {
        //     console.log(this.value); //! 每次输入都会输出 - 不能这么做
        // }
        // 函数防抖：在事件被触发n秒后再执行回调，如果在这n秒内事件又被触发，则重新计时。
        function vibration(fn, delay) {
            let timer = null;
            return function () {
                if (timer) {
                    clearTimeout(timer);
                }
                timer = setTimeout(() => {
                    fn.apply(this, arguments);
                }, delay);
            }
        }
        // 测试函数防抖
        oInput.oninput = vibration(function () {
            console.log(this.value); //! 输入停止n秒后输出
        }, 500)
    </script>
```

#### ②函数节流

```js
    <script>
        // 函数节流：在事件被触发n秒后再执行回调，如果在这n秒内事件又被触发，则不执行回调。
        window.onresize = throttle(1000)
        function throttle(delay) {
            var date = Date.now();
            return function () {
                console.log("resize")
                if (Date.now() - date >= delay) {
                    date = Date.now();
                    console.log("1秒内只能触发一次")
                }
            }
        }
    </script>
```

#### ③循环添加事件

```js
    <ul>
        <li>111</li>
        <li>222</li>
        <li>333</li>
    </ul>
    <script>
        var oLis = document.getElementsByTagName('li');
        for (var i = 0; i < oLis.length; i++) {
            // 每个li都有一个点击事件，点击时输出当前li的索引
            oLis[i].onclick = (function (index) {
                return function () {
                    console.log(index);
                }
            })(i) // 立即执行函数，将i作为参数传递，返回一个函数，赋值给oLis[i].onclick
        }
    </script>
```



### 宏任务与微任务

```js
    <script>
        //数字即是执行顺序：111 222 333 444 555
        console.log(111);
        setTimeout(() => {
            console.log(555);
        }, 0);
        Promise.resolve().then(() => {
            console.log(333);
        }).then(() => {
            console.log(444);
        })
        console.log(222);
    </script>
```

![image-20260214130819453](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20260214130820623.png)



## ES6 - ES13

```js
1. ES6新增方法：
    let&const、解构赋值、箭头函数、模版字符串
    Symbol、Map、Set常用数据类型
    Proxy 重新定义了数据劫持的能力
    Reflect 定义了一套标准化的数据操作方式
    Promise解决了异步逻辑嵌套回调地狱问题，定义异步逻辑3种状态 pending/fullfilled/rejected, 搭配then/catch/all/race和async+await语法糖
    Generator函数，可以将异步逻辑划片执行(大厂面试)：同步遍历器，会返回一个遍历器对象，即可以一次遍历 Generator 函数内部的每一个状态
    class类
    modules模块化
2. var & let & const 区别：
    var: 存在声明提前，不存在作用域限制
    let: 不会声明提前， 存在暂时性死区，存在块级作用域限制
    const: 常量定义，无法修改
3. 箭头函数：()=>{} ES6推出的，低版本浏览器有兼容性问题。箭头函数没有自己的 this 指向(默认指向window)
4. 解构赋值： let { type, payload } = data   //{ type: "", payload: "" }
5. ...展开合并：
    [...arr1, ...arr2]
    {...obj1, ...obj2}
6. 异步处理方案：
    ①回调函数
    ②Promise - 解决回调地狱(默认pending状态，resolve()后进入fullfilled状态进入.then，如果rejected则进入.catch)
        - Promise.all() 所有异步都结束(fullfilled)进入.then
        - Promise.race() 所有异步任一返回结果就进入.then 或 任一被rejected则就进入.catch
        - Promise.any() 所有异步都变成rejected才会结束
    ③generator 生成器 yield
    ④async await
7. class 类：与Java的类写法基本一致，支持箭头函数、构造函数、babel-loader
8. modules 模块化规范：
    ①导出 export default aaa
      导入 import obj from './a'
    ②导出 export {bbb}  或 export var bbb = function() {}
      导入 import {bbb} from './b'
    AMD - 前端异步加载 - 提前下载，提前加载 require.js
    CMD - 异步加载 - 提前下载，按需加载 - sea.js
    CommonJS - 同步加载(webpack) -->  require('./b')   =>module.exports   =>exports
    ES6可以导入某几个方法；CommonJS是默认导入一个文件
9. Generator 异步遍历器
    场景：一个数组中均为异步任务，在 for 循环中进行挨个按顺序执行
```

### Generator 异步遍历器

```js
    <script>
        function timer(t) {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve("data-" + t);
                }, t);
            })
        }
        // 定义一个异步遍历器，每次yield返回一个promise
        async function *gen() {
            yield timer(1000)
            yield timer(2000)
            yield timer(3000)
        }
        // 使用 async + await 遍历异步遍历器
        async function test() {
            let g = gen()
            // 将异步遍历器放入在数组中
            let arr = [g.next(), g.next(), g.next()];
            //每次循环都等待上一个promise执行完成，也就是 for await 循环中的代码块完全执行完
            for await (let item of arr) {
                console.log("start-", Date.now());
                console.log(item);
                console.log("end-", Date.now());
            }
        }
        test(); // 依次1s后输出 data-1, 此时再过2s后输出 data-2, 此时再过3s后输出 data-3
    </script>
```





## TypeScript





## Vue

```js
1. 单项数据流 & 双向数据绑定
    单向数据流：修改一边，另一边不会同步改变
    双向数据绑定：数据或视图任何一个发生改变，另一个都会实时改变
2. Object.defineProperty 有什么缺点
    ①无法监听 es6 的 Set、Map 变化
    ②无法监听 class 类型的数据
    ③属性的新加或删除也无法监听
    ④数组元素的增加和删除也无法监听
3. MVC/MVP/MVVM
    MVC: Model-View-Controller (观察者模式通过View，强依赖Model，无法组件化无法复用)
    MVP: Model-View-Presenter  (View不依赖Model，View可以组件化，View-Model需要手动同步，维护困难)
    MVVM: Model-View-ViewModel (双向绑定机制，提高代码可维护性和复用性)
4. 生命周期
    vue2: beforeCreate/created, beforeMount/mounted, beforeUpdate/updated, beforeDestroy/destroyed
    vue3: setup/setup, onBeforeMount/onMounted, onBeforeUpdate/onUpdated, onBeforeUnmount/onUnmounted
5. Vue响应式数据原理？
    响应式原理：
      1)利用【Object.defineProperty】的方法里的 【setter 和 getter】 方法的【观察者模式来拦截】。
      2)组件初始化会【给每个data属性注册 setter和gette】r，然后再 new 一个自己的 【watcher】 对象，它会立即调用【render函数生成虚拟DOM】
      3)render时就会需要data的属性值，就会遍历所有的 watcher 对象，对虚拟DOM会进行新旧对比diff算法，以最小patch补丁的方式更新DOM
    Proxy 与 Object.defineProperty 优劣对比？
    Proxy: 可以直接监听对象而非属性，监听数组的变化，超过13种拦截方法，返回的是新对象，只操作新的对象达到目的，有浏览器兼容性问题
    Object.defineProperty: 遍历对象属性直接修改，兼容性好，支持IE9
6. Composition API组合式API有哪些新的体验，为什么需要这个？
    ①可读性和可维护性高，类似 react 的 hook 写法
    ②更好的重用逻辑代码，在 Option API中只能通过 Mixins重用逻辑代码，容易发生命名冲突且关系不清晰
    ③解决生命周期函数包含不相关的逻辑，又不得不把逻辑分离到了不同方法中的问题
7. Vue 对比 jQuery
    jQuery: 专注视图层，通过直接操作 DOM 去实现页面的逻辑渲染
    Vue: 专注于数据层，数据双向绑定，最终表现在DOM层面，减少了DOM操作；组件化思想，使项目子集职责清晰，提高开发效率，方便重用和协同开发
8. Vue 单文件组件中定义全局CSS：<style>标签中不添加 scoped 属性，默认为全局 CSS 样式
9. $root, $parent, $refs
    $root: 访问父组件属性和方法，根父组件实例
    $parent: 访问父组件属性和方法，最近一级的父组件实例
    $refs: 子组件标签定义 ref 属性，在父组件中可以使用 $refs 访问子组件实例
10. 自定义指令(用的少)：标签上可以添加一个 v-xxx 指令，就能够在插入到DOM后，对该节点进行相应的操作；分全局指令和局部指令
11. 过滤器(vue3已废弃)：全局/局部过滤器，对数据进行处理，可以传递参数，使用方式参考 {{ message | capitalize }}
12. Vue单页面应用的优缺点：
    优点：
      1)内容改变不需要加载整个页面，响应性极高
      2)没有页面之间的切换，不会出现白屏现象
      3)服务器压力小，吞吐能力提高
      4)良好的前后端分离
    缺点：
      1)首次加载耗时较多 - 需要路由懒加载处理
      2)SEO问题，不利于搜索引擎收录 - 需要SSR服务端渲染处理
      3)容易造成 CSS 命名冲突
      4)前进、后退、地址栏、书签等需要程序管理，页面复杂度高，开发成本较高
13. Vue-router 使用 params 和 query 传参有什么区别？
    params: 需要name来引入，接参都是 this.$route.query 和 this.$route.params; 路由的一部分，必须要有 
    query: 需要path来引入，接参都是 this.$route.query 和 this.$route.params; 拼接在 url 后面的参数
14. keep-alive的作用
    vue的内置组件，可以使被包含的组件保留状态，避免重新渲染。即mounted/created等钩子函数只会在第一次进入组件时调用，再次切换回来将不会调用；
    切换时做其他事情，需要使用【actived和deactived】这两个钩子函数(只有被 keep-alive 包裹时才有这两个生命周期钩子函数)。
15. vue如何实现单页面应用：利用 hash 和 history 以及监听其路由变化
    hash: 监听浏览器 onhashchange() 事件变化，查找对应的路由规则
    history: 监听浏览器的 pushState() 和 replaceState() 和 onpopstate监听URL变化
16. 列举vue中指令和用法：
    v-if    判断是否隐藏，用来判断元素是否创建
    v-show  元素的显示和隐藏，类似css中的 display的block和none
    v-for   遍历数据，必须添加key，提高性能(虚拟DOM的diff算法打补丁更新DOM)
    v-bind  绑定属性
    v-model 双向绑定属性
17. 如何实现一个路径渲染多个组件？
    通过命名视图<router-view>允许同一界面拥有多个【单独命名】的视图。没有取名字则为 default
    比如：
      <router-view class="view left-sidebar" name="LeftSidebar"></router-view>
      <router-view class="view main-content"></router-view>
      <router-view class="view right-sidebar" name="RightSidebar"></router-view>
18. 如何实现多个路径共享一个组件？
    只需要将多个路径的 component 字段的值设置为同一个组件即可
    比如：
      { path: '/', component: Home }
      { path: '/home', component: Home }
19. 如何监测动态路由的变化？
    ①通过 watch 方法来对 $route 进行监听，或者 ②通过导航守卫的钩子函数 beforeRouteUpdate 来监听它的变化。
20. vue-router 中的 router-link 上的 v-slot 属性怎么用？
    高阶API，通过作用域插槽暴露底层的定制能力。多数情况用在 NavLink 这样的自定义组件里。
    比如：
      <router-link custom to="/films" v-slot="{isActive, navigate}">
    	<li :class="isActive ? 'jerry-active' : ''" @click="navigate">电影</li>
      </router-link>
21. Vue中如何去除 url 中的 #
    将路由模式改为 history。
    问题：页面路径访问时有些 url 会认为是资源请求，可能会出现 404 的情况。
    解决：服务端的 nginx 中配置默认没有找到的页面都重定向到 首页 index.html
22. $route 和 $router 的区别
    $route: 获取路由的信息，包含 name,meta,path,hash,query,params,fullPath,matched,redirectedFrom等
    $router: 操作路由的，它是VueRouter实例，包含了路由跳转方法 push, go, replace, 钩子函数等
23. Vue 路由守卫(路由拦截器)
    router.beforeEach(...)   router.afterEach(...)
    参数：
      to 即将要进入的目标路由对象
      from 当前导航即将要离开的路由对象
      next 调用该方法后，才能进入下一个钩子函数 afterEach
24. Vue路由底层原理：
    Vue中利用数据劫持defineProperty在原型 prototype 上初始化了一些 getter，分别是router代表的当前Router实例、route代表的Router信息
    在install中也全局注册了router-view、router-link，其中 Vue.util.defineReactive 是vue里观察者劫持数据的方法:
      劫持 _route 当出发 setter方法时，会通知到依赖的组件
    接下来的init中，会挂载判断是路由的模式，是history或者是hash，点击行为按钮，调用 hashchange 或者 popstate 监听事件方法
    同时更新_route，再触发 route-view 的重新渲染。
25.
```



## React

```

```





## NodeJS

```js
1. nodejs创建静态服务器：要使用HTTP服务器和客户端，则必须 require('http')
2. CommonJS规范 与 ES6模块化规范
    CommonJS规范：require 导入，module.exports 导出
    ES6模块化规范：import 导入，export default 导出
3. socket通信/聊天
    websocket 利用了 HTTP 协议来建立连接，且必须由浏览器发起。
    该请求与HTTP普通请求的区别：
    1)GET请求地址不再是路径，而是 ws 或 wss 的统一资源标志符（URI），其中 wss 表示使用了 TLS 的 Websocket。
    2)请求头是 Upgrade: websocker 和 Connection: Upgrade 表示连接要被转换为 websocket 连接
    3)Sec-WebSocket-Key 用于标识这个连接，并非用于加密数据
    4)Sec-WebSocket-Version 指定了 WebSocket 的协议版本
4. MongoDB 非关系型数据库：
    关系型数据库：sql语句表之间关系可以连表增删改查、事务一致性/事务回滚等，如 mysql、oracle、sqlserver...
    非关系型数据库：sql语句没有表关系，轻量、高效、自由，如 mongoDB、redis...
    MongoDB：collection(集合/表)、document(文档/行数据)、field(域/字段)
    MongoDB数据库连接通过 'mongoose' 库的引入实现。
5. token(jwt-json) 与 session(express-session) 配合 cookie(登陆鉴权)
    (1/2)浏览器-POST账号密码-服务端-校验账号密码-数据库 - 校验成功-用户信息存session-返回sessionId
    (2/2)浏览器-存储sessionId-请求接口自动携带Cookie:sessionId-数据库查session - 校验成功-接口返回
    以CSRF攻击为例：
      cookie：用户点击了链接，cookie未失效，导致发起请求后后端以为是用户正常操作，于是放行进行操作
      token：用户点击了链接，由于浏览器不会自动带上token，所以即使发了请求，后端的token验证不会通过，所以不会进行扣款操作
6. token 存在 localStorage 里，当过期时，过期的 token 怎么处理？
    token过期：后端会返回一个 401 鉴权失败的状态码给前端，前端接收后重定向到登录页，引导用户登录。【axios拦截器中进行判断和重定向】
7. 使用原生Node.js操作 cookie？
    获取cookie：req.headers.cookie
    设置cookie：res.writeHead(200, {'Set-Cookie': 'myCookie=test', 'Content-Type': 'text/plain'})
8. nextTick 和 setImmediate 的区别：
    nextTick: 延迟加载，放在当前队列的最后一个执行
    setImmediate: 延迟加载，在下一个队列的队首执行
9. koa 与 express 区别：
    相同：都是 nodejs 的快速开发框架
    不同：
      ①语法：最大区别
        express 的异步采用的是回调函数的形式
        koa 支持generator+yield，支持async+await，更加优雅
      ②中间件：
        koa 采用洋葱模型，进去顺序执行，出去反向执行，支持context传递数据。
        express 需要引入插件，不支持 await 中间件异步函数
      ③集成度：
        express 内置了很多中间件，集成度高、省心
        koa 轻量简洁、容易定制
10. koa 中间件的实现原理
    1)每个中间件接收两个参数：Context, next 只要调用next函数就可以把执行权交给下一个中间件
    2)如果没有调用 next，执行权就不会传递下去
    3)多个中间件会形成一个 栈 解构，以先进后出的顺序执行。
11. 图片上传到服务器的过程
    Multer 是nodejs的一个中间件，只会处理 multipart/form-data 类型的表单数据，主要用于上传文件。
12. 服务端渲染
    页面渲染在服务端完成，最终的HTML字符串直接通过请求发送给客户端。
    服务端渲染的优势：利于 SEO 优化、首屏加载快(客户端接收到的是完整HTML页面)
13. nodejs 优缺点 和 适用场景
    优点：事件驱动、异步变成、简单易学、非阻塞IO、性能较高、轻量高效
    缺点：单线程、可靠性低、开源组件库参差不齐-兼容性差、不适合做企业级应用开发-特别是复杂业务
    场景：
      1)大量 ajax 请求的应用
      2)实时应用：在线聊天、实时通知推送等
      3)工具类应用：海量工具，前端压缩部署、桌面图形界面等
      3)高并发、I/O密集、少量业务逻辑和不依赖可靠性的场景，nodejs 还有其一席之地
```



## git | webpack

```js
1. git命令相关
    git init 初始化仓库
    git status 查看各个区域的代码状态
    git log 查看commit记录
    git reflog 查看完整记录【亮点】
    git add 添加工作区代码到暂存区
    git commit 暂存区代码的提交
    git reset 代码的版本回退【亮点】
    git stash 将暂存处代码收起来【亮点】
    git stash pop 将收起来的暂存区的代码释放出来【亮点】
    git tag 可以打标签【亮点】
    git branch 基于当前分支创建一个分支
    git checkout 切换分支
    git merge 合并分支
    git remote add origin 添加远端仓库地址
    git clone 克隆仓库
    git pull 下拉对应分支代码
    git push 上传对应分支代码
   【规范】gitlab 和 公司 git 规范
      4个环境：开发环境DEV-dev分支、测试环境TEST-test分支、预发布环境UAT-uat分支、生产环境PROD-master分支
2. sass 和 scss
    sass是 css 的辅助工具，在CSS语法上增加了变量、嵌套、混合、导入等高级功能。
    scss是 sass 的一个语言版本，.scss 文件的特点是层级【靠{}】来区分，.sass文件的特点是层级【靠缩进】来区分。
3. 前端工程化：gulp & webpack
    gulp - src=>pipe(scss翻译).pipe(css合并).pipe(css压缩)=>dist
    gulp - src=>pipe(模块化编译).pipe(js压缩)=>dist
        流程化
    webpack
        模块化，默认支持的 commonjs 规范。
        所有js模块打包生成一个js文件，编译解析浏览器不能识别的语言(如scss/vue/jsx/ts/es6等)
        配置：入口、出口、devServer启动(自动刷新/热更新/反向代理)、sourcemap-调试代码.map地图
        loaders: sass-loader/css-loader/file-loader/babel-loader/vue-loader/postcss-loader
        plugin: 压缩、提取公共库
4. webpack配置、代码分割流程及操作
    webpack包含：mode模式、entry入口、output出口、plugins插件、loader加载器、resolve、devServer开发服务器相关配置
    组件模块化导入的时候可以采用懒加载的形式，就会单独打包对应的代码。（路由匹配到就会加载，提高首屏加载速度）
5. webpack 4大核心理念、编译原理：【entry入口、output出口、plugins插件、loader加载器】  -  一切皆为模块
6. webpack 构建优化(打包时间过长，可以优化时间短点 20s)：
    1)提取公共库，避免重复引用。（使用DllPlugin把第三方库文件分离出来单独编译，并且缓存，极大减少业务页面编译时间）
    2)happypack，多线程解析文件，如babel-loader等耗时较长的
    3)缓存 cache-loader
    4)loaders 尽可能配置解析路径include参数，排除路径exclude参数，减少解析时查询范围
    5)dev 阶段 devtool 设置成 cheap-module-eval-source-map，已经能满足调试需求，编译更快
    6)prod 阶段 去掉 source-map
```



## 性能优化



## 浏览器原理



















