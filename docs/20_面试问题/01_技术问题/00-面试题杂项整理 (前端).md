---
title: 00-面试题杂项整理（前端）
date: 2017-5-3 00:09:33
tags:
- 面试题
- 前端
categories: 
- 20_面试问题
- 01_技术问题
---



## HTML

```
1. HTML5 结构语义化：
	用正确的标签做正确的事情。p段落、h标题、aside边栏、main主要内容等...
	对开发者：便于维护、较好的呈现内容结构和代码结构、易于阅读；
	对浏览器：有利于SEO，搜索引擎爬虫依赖于标签、方便其他设备解析、提高可访问性
2. HTML5 新特性：
	新增：主要是关于图像、位置、存储、多任务等功能的增加
	    媒体播放的 video/audio 元素
	    本地存储 localStorage 长期存储(浏览器关闭不消失) / sessionStorage 数据浏览器关闭删除
	    语义化更好的内容元素(article,footer,header,nav,section)
	    表单控件(calendar、date、time、email、url、search)
	    新的技术(webworker,websocket,geolocation)
    移除：纯表现的元素(basefont, big, center, font, s, strike, tt, u)、可用性有负面影响的元素(frame, frameset, noframes)
3. cookies, sessionStorage, localStorage 区别：
	cookies(最大4k): 标识用户身份，存储在用户本地终端(通常经过加密)，始终自动同源http请求中携带
	sessionStorage(5M或更大): 数据在当前浏览器窗口关闭后自动删除
	localStorage(5M或更大): 持久化存储数据，浏览器关闭不会丢失除非主动删除
4. 浏览器的渲染机制的步骤：
	处理HTML并构建DOM树 → 处理CSS构建CSSOM树 → 将DOM与CSSOM合并为一个渲染树 → 布局并计算每个节点的位置 → 调用GPU绘制合成图层并显示在屏幕上
	注意：CSSOM树会阻塞渲染，因此CSS选择器要尽量层级扁平，减少过度层叠；JS文件要按需加载，不在首页去全部加载
5. 重绘（Repaint）和回流（Reflow）
	重绘：节点需要更改【外观】而不影响布局的，如改变color就是重绘
	回流：【布局或者几何属性】改变就是回流
	减少重绘和回流：
	① 批量修改 DOM
	② 复杂动画效果，使用绝对定位使其脱离文档流
	③ CSS3硬件加速(GPU加速) transform/opacity/filters 这些动画不会引起回流重绘
6. data:属性的用法，有何优势？
    data-* 的值的获取和设置，2种方法：
	① [无兼容性问题，不优雅]getAttribute() 获取 data-属性值；setAttribute() 设置 data-属性值
	② [有兼容性问题，更优雅]HTML5新方法：如 data-jerry, dataset.jerry 获取data-jerry属性值； dataset.jerry="张三" 设置 data-jerry 属性值
	优势：自定义的数据可以让页面拥有更好的交互体验
```



## CSS

```
1. display:none; 与 visibility:hidden; 的区别
    相同：都可以让元素不可见
    区别：
      1)display:none 元素完全从渲染树中消失，渲染时不占任何空间；visibility:hidden 不会让元素从渲染树消失，渲染时占据空间，只是内容不可见
      2)修改常规常规流中的元素 display 会造成【文档重排】、修改 visibility 属性只会造成本元素的【重绘】
2. 外边距折叠
    相邻的两个或多个 margin 会合并成一个 margin，叫做外边距折叠。规则如下：
    ①两个或多个相邻的普通流中的【块元素垂直方向】上 margin 会折叠
    ②【浮动】元素或【inline-block】元素或【绝对定位】元素 margin 不会和垂直方向上的其他元素 margin 折叠
    ③创建了块级格式上下文(BFC)的元素，不会和它的子元素发生margin折叠
3. z-index是什么？position的值什么时候可以触发？
    z-index 设置元素的堆叠顺序。
    注意：z-index 仅能在定位元素上有效，position = relative / absolute / fixed / sticky 时才会触发层级设置。
4. box-sizing 的有效值以及对应的盒模型规则：
    1)box-sizing:content-box; 默认值，宽度和高度分别应用到元素的内容框；在宽度和高度【之外】绘制元素的【内边距和边框】。
    2)box-sizing:border-box; 【内边距和边框】都在已设定的宽度和高度【之内】进行绘制。内部元素的宽高会被挤压，使我们更容易控制元素的宽高。
    3)box-sizing:inherit; 继承父元素的 box-sizing 属性的值。
5. 移动端适配怎么做？
    ①【meta 标签 viewport】（视口适配）
    移动端初始视口大小默认是 980px，为了解决页面缩放体验问题，代码头部会加入一行 viewport 原标签，告诉浏览器视口的宽度为设备的宽度。
    属性含义：
        initial-scale: 第一次进入页面的初始比例
        minimum-scale: 允许缩小最小比例
        maximum-scale: 允许放大最大比例
        user-scalable：允许使用者缩放，1 or 0（yes or no）
    ②【图片适配】
    img { max-width: 100%; } 此时图片会自动缩放，同时图片最大值为自身的100%
    为什么不用 img { width: 100%; } ? 当容器大于图片宽度时，图片会无情的拉伸变形。
    ③【媒体查询】
    自动检测屏幕宽度，然后加载相应的CSS文件或样式，语法 @media screen and (min-width:1200px) { 样式代码 }
    ④【动态 rem 方案】
    rem 和媒体查询配合实现响应式布局。
    	px：像素，屏幕上显示数据的最基本的点，HTML中默认单位；
    	em：相对于【父元素的 font-size】 的百分比大小；
    	rem：相对于【根元素的 font-size】的大小，如
    	    css 中 html{ font-size: 100px; }
    	    js  中动态设置 fontSize，以 iphone6的750px为标准宽度等比缩放设计稿，使用375px进行计算，计算方式
    	    document.documentElement.style.fontSize = document.documentElement.clientWidth / 375 * 100 + 'px';
6. CSS3中的 transform? transition? animation? 区别是什么？
    transform: 静态样式，对元素进行旋转rotate、扭曲skew、缩放scale、移动translate、矩阵变形matrix
    transition: 样式过度，从一种效果改变为另一种效果，复合属性，分别可以设置 CSS属性、过度效果时间、速度曲线、过渡开始的延迟时间
    animation: 动画属性，由 @keyframes 来描述每一帧的样式
    区别：
    1) transform 仅描述元素静态样式，尝尝配合 transition 和 animation 使用
    2) transition 通常和 hover 等事件配合使用，animation 是自发的，立即播放
    3) transition 可与 js 配合使用，js设定要变化的样式，transition 负责动画效果
    4) animation 可设置循环次数
    5) animation 可设置每一帧的样式和时间，transition 只能设置头尾
7. 父元素和子元素的宽高不固定，如何实现水平垂直居中？
    方式1：【定位+位移】父元素相对定位，子元素绝对定位 + left:50% + top: 50% + transform: translate(-50%, -50%) 位移
    方式2：【弹性布局】主轴和侧轴居中，即 display:flex; justify-content:center; align-item:center; 
8. 假设高度默认100px，写出三栏布局、其中左栏、右栏各位300px，中间自适应
    方式1：浮动（盒子1left左浮动、盒子2right右浮动、盒子3center自动填满中间）必须是这个顺序！
    方式2：绝对定位（盒子1定位left0、盒子3定位right0）
    方式3：弹性布局（盒子1宽度300，盒子3宽度300，盒子2设置flex:1）
```



## JavaScript

```
1. JS内置对象：
    数据封装类对象：Object, Array, Boolean, Number, String
    其他对象：Function, Arguments, Math, Date, RegExp, Error
    ES6新增对象：Symbol(标识唯一性的ID), Map, Set, Promises, Proxy, Reflect
2. 如何最小化重绘(repaint)和回流(reflow)？
    ①对元素复杂操作时，先隐藏(display:none)，操作完再显示
    ②创建多个DOM节点时，使用 DocumentFragment 创建完后一次性的加入 document
    ③缓存 Layout 属性值，如 var left=elem.offsetLeft; 这样多次left只产生一次回流
    ④尽量避免用 table 布局
3. JS作用域链？
    全局函数无法查看局部函数的内部细节，局部函数可以查看其上层的函数细节，直至全局细节；
    当前作用域函数没有找到属性或方法，会向上层作用域[[Scoped]]查找，直至全局函数，这就是作用域链。
4. 数据请求？XHR, fetch, jsonp
   XHR: XMLHttpRequest()，  xhr.abort();//取消或终止请求
   fetch: w3c新的标准，fetch().then(res => res.json()).then(res => console.log(res))
   jsonp: 解决跨域，且只有get请求；原理是动态创建 script 标签，请求数据没有限制
5. 跨域和同源策略
    同源：同协议、同域名、同端口 才能进行数据请求和响应交互。非同源就会触发CORS跨域。
    ① JSONP：利用动态创建 script 标签，请求数据没有限制，解决跨域。
    ② CORS：依赖服务端对前端的请求头进行放行，不做限制（Access-Control-Allow-Origin:*）
    ③ 反向代理：前端访问无跨域问题的代理服务器，代理服务器再去访问目标服务器
6. 面向对象
	1)构造函数：通过函数方法创建一个对象，可以 new 一个该对象
	2)原型：Test.prototype.getName = function() {} 缺点是：原型很容易被覆盖而丢失原有的功能
	3)继承：Test.call(this, ...) 或 Test.apply(this, ...) 然后原型继承 Test2.prototype = Test.prototype
	4)原型链：任何一个实例，通过原型链找到它上面的原型，该原型对象中的方法和属性，可以被所有的原型实例共享。
7. 闭包：实际开发中使用到的闭包
	【函数内部返回一个函数】，而这个函数又被外界使用，导致该函数和返回的函数都不会被垃圾回收，此用法称之为闭包。
	使用的多了可能会导致【内存泄露】。
	场景1：函数防抖（搜索查询），即 input 绑定一个延迟500ms定时器去延时请求搜索查询来实现防抖，而不是所有输入都请求数据
	场景2：函数节流（图表自适应），即 resize 用于 echart 重新渲染图标大小时，拖动窗口超过如1s时，才重新设置 echarts 的 option渲染图标
	场景3：循环添加事件（ul li），即 ul li 标签遍历 li 添加事件时，遍历会瞬间执行完，使用闭包可以让每个点击对应每个事件，而不是直接全部执行完毕
8. 数组去重：
		var myset = new Set(arr)
		var res = Array.from(myset)
9. 数组合并：
	①concat    ②[...a, ...b]展开运算符    ③[a, b].flat()扁平化
10. cookie 和 session - 【登陆鉴权如何实现的？】
    cookie: 客户端向服务端登陆的时候，服务端通过响应头去set-cookie，在浏览器注入cookie(可能携带隐私敏感信息) -- 可能会被模拟cookie即模拟登陆
    session: 服务端建立用户信息表和生命周期机制，服务端在客户端登陆时将此信息返回为set-cookie，客户端存储到cookie或localStorage均可
             每次请求携带该验证信息，服务端去验证是否有效或过期
             一般是 cookie 中存 sessionId --或-- localStorage 中存储 token
11. 协商缓存和强缓存的区别
    相同：都是浏览器对静态资源文件的缓存机制
    不同：
    	- 强缓存：客户端直接查看本地的缓存文件是否过期，如果没有过去就直接取用。【不涉及服务端交互】
    	          依靠响应头上的 expires(绝对时间) 和 cache-control(相对时间) 两个值来对比
    	- 协商缓存：客户端去询问服务器对应的文件是否有更新，如果有更新才会重新请求。
    	          依靠 last-modified(最后更新时间) 和 etag(内容变更标识) 来确认文件是否有更新
    【一般做法】在静态文件的 url 如 xxx.js 后面追加了 ?t=时间戳 参数，可以阻止浏览器缓存，每次都可以获取到最新的信息
12.HTTP与HTTPS
    HTTP：明文传输，TCP传输交换3个包，默认端口号 80
    HTTPS：加密传输，TCP传出交换3+9=12个包，默认端口号 443，TLS加密即通过证书对双方进行身份验证
13.跨域问题解决：
    ①一般线上环境不会有跨域问题，因为前后端都部署在同一台服务器。
    ②本地开发，可能会有跨域，比如本地访问测试服务器或开发服务器的接口，基本都是后端设置允许跨域为 * ，有时候前端也需要配置 devServer 中配置 Proxy
    ③极少的情况下，项目中可能会访问一些第三方api，如定位、天气这些接口，可能会根据接口的情况使用 jsonp 进行跨域处理。
```



## TypeScript





## Vue2|Vue3|React





## NodeJS



## 工程化|打包工具



## 性能优化



## 浏览器原理

