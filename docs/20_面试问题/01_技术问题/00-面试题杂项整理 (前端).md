---
title: 00-面试题杂项整理（前端）
date: 2017-5-3 00:09:33
tags:
- 面试题
- 前端
categories: 
- 20_面试问题
- 01_技术问题
---



## HTML

```
1. HTML5 结构语义化：
	用正确的标签做正确的事情。p段落、h标题、aside边栏、main主要内容等...
	对开发者：便于维护、较好的呈现内容结构和代码结构、易于阅读；
	对浏览器：有利于SEO，搜索引擎爬虫依赖于标签、方便其他设备解析、提高可访问性
2. HTML5 新特性：
	新增：主要是关于图像、位置、存储、多任务等功能的增加
	    媒体播放的 video/audio 元素
	    本地存储 localStorage 长期存储(浏览器关闭不消失) / sessionStorage 数据浏览器关闭删除
	    语义化更好的内容元素(article,footer,header,nav,section)
	    表单控件(calendar、date、time、email、url、search)
	    新的技术(webworker,websocket,geolocation)
    移除：纯表现的元素(basefont, big, center, font, s, strike, tt, u)、可用性有负面影响的元素(frame, frameset, noframes)
3. cookies, sessionStorage, localStorage 区别：
	cookies(最大4k): 标识用户身份，存储在用户本地终端(通常经过加密)，始终自动同源http请求中携带
	sessionStorage(5M或更大): 数据在当前浏览器窗口关闭后自动删除
	localStorage(5M或更大): 持久化存储数据，浏览器关闭不会丢失除非主动删除
4. 浏览器的渲染机制的步骤：
	处理HTML并构建DOM树 → 处理CSS构建CSSOM树 → 将DOM与CSSOM合并为一个渲染树 → 布局并计算每个节点的位置 → 调用GPU绘制合成图层并显示在屏幕上
	注意：CSSOM树会阻塞渲染，因此CSS选择器要尽量层级扁平，减少过度层叠；JS文件要按需加载，不在首页去全部加载
5. 重绘（Repaint）和回流（Reflow）
	重绘：节点需要更改【外观】而不影响布局的，如改变color就是重绘
	回流：【布局或者几何属性】改变就是回流
	减少重绘和回流：
	① 批量修改 DOM
	② 复杂动画效果，使用绝对定位使其脱离文档流
	③ CSS3硬件加速(GPU加速) transform/opacity/filters 这些动画不会引起回流重绘
6. data:属性的用法，有何优势？
    data-* 的值的获取和设置，2种方法：
	① [无兼容性问题，不优雅]getAttribute() 获取 data-属性值；setAttribute() 设置 data-属性值
	② [有兼容性问题，更优雅]HTML5新方法：如 data-jerry, dataset.jerry 获取data-jerry属性值； dataset.jerry="张三" 设置 data-jerry 属性值
	优势：自定义的数据可以让页面拥有更好的交互体验
```



## CSS

```
1. display:none; 与 visibility:hidden; 的区别
    相同：都可以让元素不可见
    区别：
      1)display:none 元素完全从渲染树中消失，渲染时不占空间；visibility:hidden 不会让元素从渲染树消失，渲染时占空间，内容不可见
      2)修改常规常规流中的元素 display 会造成【文档重排】、修改 visibility 属性只会造成本元素的【重绘】
2. 外边距折叠
    相邻的两个或多个 margin 会合并成一个 margin，叫做外边距折叠。规则如下：
    ①两个或多个相邻的普通流中的【块元素垂直方向】上 margin 会折叠
    ②【浮动】元素或【inline-block】元素或【绝对定位】元素 margin 不会和垂直方向上的其他元素 margin 折叠
    ③创建了块级格式上下文(BFC)的元素，不会和它的子元素发生margin折叠
3. z-index是什么？position的值什么时候可以触发？
    z-index 设置元素的堆叠顺序。
    注意：z-index 仅能在定位元素上有效，position = relative / absolute / fixed / sticky 时才会触发层级设置。
4. box-sizing 的有效值以及对应的盒模型规则：
    1)box-sizing:content-box; 默认值，宽度和高度分别应用到元素的内容框；在宽度和高度【之外】绘制元素的【内边距和边框】。
    2)box-sizing:border-box; 【内边距和边框】都在已设定宽度和高度【之内】进行绘制。内部元素宽高会被挤压，使我们更容易控制元素宽高。
    3)box-sizing:inherit; 继承父元素的 box-sizing 属性的值。
5. 移动端适配怎么做？
    ①【meta 标签 viewport】（视口适配）
    移动端初始视口大小默认是 980px，为了解决页面缩放体验问题，代码头部会加入一行 viewport 原标签，告诉浏览器视口的宽度为设备的宽度。
    属性含义：
        initial-scale: 第一次进入页面的初始比例
        minimum-scale: 允许缩小最小比例
        maximum-scale: 允许放大最大比例
        user-scalable：允许使用者缩放，1 or 0（yes or no）
    ②【图片适配】
    img { max-width: 100%; } 此时图片会自动缩放，同时图片最大值为自身的100%
    为什么不用 img { width: 100%; } ? 当容器大于图片宽度时，图片会无情的拉伸变形。
    ③【媒体查询】
    自动检测屏幕宽度，然后加载相应的CSS文件或样式，语法 @media screen and (min-width:1200px) { 样式代码 }
    ④【动态 rem 方案】
    rem 和媒体查询配合实现响应式布局。
    	px：像素，屏幕上显示数据的最基本的点，HTML中默认单位；
    	em：相对于【父元素的 font-size】 的百分比大小；
    	rem：相对于【根元素的 font-size】的大小，如
    	    css 中 html{ font-size: 100px; }
    	    js  中动态设置 fontSize，以 iphone6的750px为标准宽度等比缩放设计稿，使用375px进行计算，计算方式
    	    document.documentElement.style.fontSize = document.documentElement.clientWidth / 375 * 100 + 'px';
6. CSS3中的 transform? transition? animation? 区别是什么？
    transform: 静态样式，对元素进行移动translate、缩放scale、旋转rotate、扭曲skew、矩阵变形matrix
    transition: 样式过度，从一种效果改变为另一种效果，复合属性，分别可以设置 CSS属性、过度效果时间、速度曲线、过渡开始的延迟时间
    animation: 动画属性，由 @keyframes 来描述每一帧的样式
    区别：
        1) transform 仅描述元素静态样式，尝尝配合 transition 和 animation 使用
        2) transition 通常和 hover 等事件配合使用，animation 是自发的，立即播放
        3) transition 可与 js 配合使用，js设定要变化的样式，transition 负责动画效果
        4) animation 可设置循环次数
        5) animation 可设置每一帧的样式和时间，transition 只能设置头尾
7. 父元素和子元素的宽高不固定，如何实现水平垂直居中？
    方式1：【定位+位移】父元素相对定位，子元素绝对定位 + left:50% + top: 50% + transform: translate(-50%, -50%) 位移
    方式2：【弹性布局】主轴和侧轴居中，即 display:flex; justify-content:center; align-item:center; 
8. 假设高度默认100px，写出三栏布局、其中左栏、右栏各位300px，中间自适应
    方式1：浮动（盒子1left左浮动、盒子2right右浮动、盒子3center自动填满中间）--必须是这个顺序！
    方式2：绝对定位（盒子1定位left0、盒子3定位right0）
    方式3：弹性布局（盒子1宽度300，盒子3宽度300，盒子2设置flex:1）
9. BFC, 块级格式上下文
    BFC（Block Formatting Context，块级格式上下文）是 CSS 中一种独立的渲染环境 / 布局规则。
    BFC 的元素===“封闭的独立盒子”，盒子内部元素布局都不会影响到外部元素，外部元素也不会干扰盒子内部布局，且盒子内遵循独立的布局规则。
    只要元素满足以下任意一个条件，就会创建 BFC：
        ①根元素（<html>）
        ②浮动元素（float 不为 none，比如 float: left/right）
        ③绝对定位 / 固定定位元素（position: absolute/fixed）
        ④行内块元素（display: inline-block）
        ⑤表格单元格 / 表格标题（display: table-cell/table-caption）
        ⑥溢出元素（overflow 不为 visible，比如 overflow: hidden/auto/scroll【最常用】）
        ⑦弹性 / 网格容器（display: flex/grid）
    应用场景：（触发 BFC 最常用方法，简单无副作用，添加 overflow: hidden）
    	①【清除浮动（解决父元素高度塌陷）】
    	  父元素里子元素设置浮动后，父元素会失去高度（塌陷），无法包裹子元素。【解决】给父元素触发BFC（最常用 overflow: hidden）
    	②【解决垂直方向 margin 重叠问题】
    	  两个相邻的块级元素，垂直方向的 margin 会 “合并”（取最大值，而非相加）。【解决】给其中1个元素包裹一层div触发 BFC 的父元素
    	③【阻止浮动元素覆盖普通元素】
    	  浮动元素会覆盖旁边的普通块级元素，导致布局错乱。【解决】给被覆盖的元素（如浮动的div盖住了 p 标签）p标签触发 BFC
```



## JavaScript

```
1. JS内置对象：
    数据封装类对象：Object, Array, Boolean, Number, String
    其他对象：Function, Arguments, Math, Date, RegExp, Error
    ES6新增对象：Symbol(标识唯一性的ID), Map, Set, Promises, Proxy, Reflect
2. 如何最小化重绘(repaint)和回流(reflow)？
    ①对元素复杂操作时，先隐藏(display:none)，操作完再显示
    ②创建多个DOM节点时，使用 DocumentFragment 创建完后一次性的加入 document
    ③缓存 Layout 属性值，如 var left=elem.offsetLeft; 这样多次left只产生一次回流
    ④尽量避免用 table 布局
3. JS作用域链？
    全局函数无法查看局部函数的内部细节，局部函数可以查看其上层的函数细节，直至全局细节；
    当前作用域函数没有找到属性或方法，会向上层作用域[[Scoped]]查找，直至全局函数，这就是作用域链。
4. 数据请求？XHR, fetch, jsonp
   XHR: XMLHttpRequest()，  xhr.abort();//取消或终止请求
   fetch: w3c新的标准，fetch().then(res => res.json()).then(res => console.log(res))
   jsonp: 解决跨域，且只有get请求；原理是动态创建 script 标签，请求数据没有限制
5. 跨域和同源策略
    同源：同协议、同域名、同端口 才能进行数据请求和响应交互。非同源就会触发CORS跨域。
    ① JSONP：利用动态创建 script 标签，请求数据没有限制，解决跨域。
    ② CORS：依赖服务端对前端的请求头进行放行，不做限制（Access-Control-Allow-Origin:*）
    ③ 反向代理：前端访问无跨域问题的代理服务器，代理服务器再去访问目标服务器
6. 面向对象
	1)构造函数：通过函数方法创建一个对象，可以 new 一个该对象
	2)原型：Test.prototype.getName = function() {} 缺点是：原型很容易被覆盖而丢失原有的功能
	3)继承：Test.call(this, ...) 或 Test.apply(this, ...) 然后原型继承 Test2.prototype = Test.prototype
	4)原型链：任何一个实例，通过原型链找到它上面的原型，该原型对象中的方法和属性，可以被所有的原型实例共享。
7. 闭包：实际开发中使用到的闭包
	【函数内部返回一个函数】，而这个函数又被外界使用，导致该函数和返回的函数都不会被垃圾回收，此用法称之为闭包。
	使用的多了可能会导致【内存泄露】。
	场景1：【函数防抖】（搜索查询），即 input 绑定一个延迟500ms定时器去延时请求搜索查询来实现防抖，而不是所有输入都请求数据
	场景2：【函数节流】（图表自适应），即 resize 用于 echart 重新渲染图标大小时，拖动窗口超过如1s时，才重新设置 echarts 的 option渲染图标
	场景3：【循环添加事件】（ul li），即 ul li 标签遍历 li 添加事件时，遍历会瞬间执行完，使用闭包可以让每个点击对应每个事件，而不是直接全部执行完毕
8. 数组去重： Array.from(new Set([1, 2, 2, 3, 3, 4]))  //[1,2,3,4]
9. 数组合并：
	①concat    ②[...a, ...b]展开运算符    ③[a, b].flat()扁平化
10. cookie 和 session - 【登陆鉴权如何实现的？】
    cookie: 客户端向服务端登陆的时候，服务端通过响应头去set-cookie，在浏览器注入cookie(可能携带隐私敏感信息) -- 可能会被模拟cookie即模拟登陆
    session: 服务端建立用户信息表和生命周期机制，服务端在客户端登陆时将此信息返回为set-cookie，客户端存储到cookie或localStorage均可
             每次请求携带该验证信息，服务端去验证是否有效或过期
             一般是 cookie 中存 sessionId --或-- localStorage 中存储 token
11. 协商缓存和强缓存的区别
    相同：都是浏览器对静态资源文件的缓存机制
    不同：
    	- 强缓存：客户端直接查看本地的缓存文件是否过期，如果没有过去就直接取用。【不涉及服务端交互】
    	          依靠响应头上的 expires(绝对时间) 和 cache-control(相对时间) 两个值来对比
    	- 协商缓存：客户端去询问服务器对应的文件是否有更新，如果有更新才会重新请求。
    	          依靠 last-modified(最后更新时间) 和 etag(内容变更标识) 来确认文件是否有更新
    【一般做法】在静态文件的 url 如 xxx.js 后面追加了 ?t=时间戳 参数，可以阻止浏览器缓存，每次都可以获取到最新的信息
12. HTTP与HTTPS
    HTTP：明文传输，TCP传输交换3个包，默认端口号 80
    HTTPS：加密传输，TCP传出交换3+9=12个包，默认端口号 443，TLS加密即通过证书对双方进行身份验证
13. 跨域问题解决：
    ①一般线上环境不会有跨域问题，因为前后端都部署在同一台服务器。
    ②本地开发可能会有跨域，比如本地访问测试或开发服务器的接口，基本都是后端设置允许跨域为 * ，有时前端也需要配置脚手架的 devServer 中配置 Proxy
    ③极少的情况下，项目中可能会访问一些第三方api，如定位、天气这些接口，可能会根据接口的情况使用 jsonp 进行跨域处理。
14. 事件循环机制：
    1)所有同步任务在主线程上执行，形成一个【执行栈】
    2)主线程之外，还存在一个【任务队列】，只要一步任务(setInterval, setTimeout, i/o...)有了结果，就在【任务队列】中放置一个事件
    3)一旦执行栈中的所有同步任务执行完毕，系统就会读取【任务队列】，拿到队列的第一个任务，进入执行栈，开始执行
    4)主线程不断重复步骤3)
15. 宏任务 与 微任务
    宏任务：script 全部代码、setTimeout、setInterval、I/O、UI Rendering...
    微任务：Promise、Process.nextTick(Node独有)...
16. HTTP状态码：
    200 OK 正常返回信息 || memory cache 【强缓存】
    201 Created 请求成功并且服务器创建了新资源
    202 Accepted 服务器已接收请求，但尚未处理
    301 Moved Permanently 重定向-请求的网页已永久移动到新位置
    302 Found 重定向-临时性重定向
    304 Not Modified 自动上次请求后，请求的网页未修改过【协商缓存】
    307 Internal Redirect 重定向-内部重定向
    400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次请求
    401 Unauthorized 请求未授权
    403 Forbidden 禁止访问
    404 Not Found 找不到任何与 URI 相匹配的资源
    500 Internal Server Error 服务端错误
    503 Service Unavailable 服务端无法处理的请求，服务不可用
17. 一个页面从输入URL到页面加载显示完成，这个过程都发生了什么？
    ①【域名解析IP】：浏览器查找域名对应的IP地址（DNS查询：浏览器缓存->系统缓存->路由器缓存->ISP DNS缓存->根域名服务器）
    ②【TCP三次握手】：浏览器向web服务器发送一个HTTP请求（TCP三次握手）
    ③【重定向】：服务器301重定向（从 xxx.com 重定向到 www.xxx.com）
    ④【请求】：浏览器跟踪重定向地址，请求另一个带www的网址
    ⑤【处理请求】：服务器处理请求（通过路由读取资源）
    ⑥【响应】：服务器返回一个HTTP响应（抱头中把Content-type 设置为 text/html）
    ⑦【DOM构建】：浏览器进DOM树构建
    ⑧【请求资源】：浏览器发送请求获取嵌在HTML中的资源（如图片、音频、视频、CSS、JS等）
    ⑨【显示页面】：浏览器显示完成页面
    ⑩【异步请求】：浏览器发送异步请求
18. CSRF跨站请求伪造 & XSS脚本注入攻击
    CSRF：①登陆受信任网站A，并在本地生成cookie； ②在不登出A的情况下，访问危险网站B(利用了A网站的漏洞)
        解决方案：
           1)Token验证(最常用)：前端携带token后端验证token
           2)隐藏token在head请求头中
           3)Referer验证：只接受本站请求，其他拦截掉
    XSS：不需要做任何登陆认证，通过合法的操作，向你的页面注入脚本(如js代码发送你的明文cookie外部)，即盗用cookie/破坏页面插入广告/doss攻击
        解决方案：
           1)编码：对用户输入的数据进行 HTML Entity 编码
           2)过滤：移除用户输入的和事件相关的属性、移除用户输入的style、script、iframe节点
    区别：CSRF是利用网站A本身的漏洞，去请求网站A的api；  XSS是向网站注入js代码，然后执行js代码，篡改网站的内容
```

### 闭包应用

#### ①函数防抖

```js
    <input type="text" id="mytext">
    <script>
        var oInput = document.getElementById('mytext')
        // oInput.oninput = () => {
        //     console.log(this.value); //! 每次输入都会输出 - 不能这么做
        // }
        // 函数防抖：在事件被触发n秒后再执行回调，如果在这n秒内事件又被触发，则重新计时。
        function vibration(fn, delay) {
            let timer = null;
            return function () {
                if (timer) {
                    clearTimeout(timer);
                }
                timer = setTimeout(() => {
                    fn.apply(this, arguments);
                }, delay);
            }
        }
        // 测试函数防抖
        oInput.oninput = vibration(function () {
            console.log(this.value); //! 输入停止n秒后输出
        }, 500)
    </script>
```

#### ②函数节流

```js
    <script>
        // 函数节流：在事件被触发n秒后再执行回调，如果在这n秒内事件又被触发，则不执行回调。
        window.onresize = throttle(1000)
        function throttle(delay) {
            var date = Date.now();
            return function () {
                console.log("resize")
                if (Date.now() - date >= delay) {
                    date = Date.now();
                    console.log("1秒内只能触发一次")
                }
            }
        }
    </script>
```

#### ③循环添加事件

```js
    <ul>
        <li>111</li>
        <li>222</li>
        <li>333</li>
    </ul>
    <script>
        var oLis = document.getElementsByTagName('li');
        for (var i = 0; i < oLis.length; i++) {
            // 每个li都有一个点击事件，点击时输出当前li的索引
            oLis[i].onclick = (function (index) {
                return function () {
                    console.log(index);
                }
            })(i) // 立即执行函数，将i作为参数传递，返回一个函数，赋值给oLis[i].onclick
        }
    </script>
```



### 宏任务与微任务

```js
    <script>
        //数字即是执行顺序：111 222 333 444 555
        console.log(111);
        setTimeout(() => {
            console.log(555);
        }, 0);
        Promise.resolve().then(() => {
            console.log(333);
        }).then(() => {
            console.log(444);
        })
        console.log(222);
    </script>
```

![image-20260214130819453](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20260214130820623.png)



## ES6 - ES13

```
1. ES6新增方法：
    let&const、解构赋值、箭头函数、模版字符串
    Symbol、Map、Set常用数据类型
    Proxy 重新定义了数据劫持的能力
    Reflect 定义了一套标准化的数据操作方式
    Promise解决了异步逻辑嵌套回调地狱问题，定义异步逻辑3种状态 pending/fullfilled/rejected, 搭配then/catch/all/race和async+await语法糖
    Generator函数，可以将异步逻辑划片执行(大厂面试)：同步遍历器，会返回一个遍历器对象，即可以一次遍历 Generator 函数内部的每一个状态
    class类
    modules模块化
2. var & let & const 区别：
    var: 存在声明提前，不存在作用域限制
    let: 不会声明提前， 存在暂时性死区，存在块级作用域限制
    const: 常量定义，无法修改
3. 箭头函数：()=>{} ES6推出的，低版本浏览器有兼容性问题。箭头函数没有自己的 this 指向(默认指向window)
4. 解构赋值： let { type, payload } = data   //{ type: "", payload: "" }
5. ...展开合并：
    [...arr1, ...arr2]
    {...obj1, ...obj2}
6. 异步处理方案：
    ①回调函数
    ②Promise - 解决回调地狱(默认pending状态，resolve()后进入fullfilled状态进入.then，如果rejected则进入.catch)
        - Promise.all() 所有异步都结束(fullfilled)进入.then
        - Promise.race() 所有异步任一返回结果就进入.then 或 任一被rejected则就进入.catch
        - Promise.any() 所有异步都变成rejected才会结束
    ③generator 生成器 yield
    ④async await
7. class 类：与Java的类写法基本一致，支持箭头函数、构造函数、babel-loader
8. modules 模块化规范：
    ①导出 export default aaa
      导入 import obj from './a'
    ②导出 export {bbb}  或 export var bbb = function() {}
      导入 import {bbb} from './b'
    AMD - 前端异步加载 - 提前下载，提前加载 require.js
    CMD - 异步加载 - 提前下载，按需加载 - sea.js
    CommonJS - 同步加载(webpack) -->  require('./b')   =>module.exports   =>exports
    ES6可以导入某几个方法；CommonJS是默认导入一个文件
9. Generator 异步遍历器
    场景：一个数组中均为异步任务，在 for 循环中进行挨个按顺序执行
```

### Generator 异步遍历器

```js
    <script>
        function timer(t) {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve("data-" + t);
                }, t);
            })
        }
        // 定义一个异步遍历器，每次yield返回一个promise
        async function *gen() {
            yield timer(1000)
            yield timer(2000)
            yield timer(3000)
        }
        // 使用 async + await 遍历异步遍历器
        async function test() {
            let g = gen()
            // 将异步遍历器放入在数组中
            let arr = [g.next(), g.next(), g.next()];
            //每次循环都等待上一个promise执行完成，也就是 for await 循环中的代码块完全执行完
            for await (let item of arr) {
                console.log("start-", Date.now());
                console.log(item);
                console.log("end-", Date.now());
            }
        }
        test(); // 依次1s后输出 data-1, 此时再过2s后输出 data-2, 此时再过3s后输出 data-3
    </script>
```





## TypeScript





## Vue2|Vue3|React





## NodeJS



## 工程化|打包工具

```

```



## 性能优化



## 浏览器原理

