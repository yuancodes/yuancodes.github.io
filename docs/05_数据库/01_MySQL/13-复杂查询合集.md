---
title: 13-复杂查询合集
date: 2017-6-18 23:04:05
tags:
- MySQL
categories: 
- 05_数据库
- 01_MySQL
---

![image-20200812132737977](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20200812132738.png)

### 1. 行转列,列转行

```mysql
DROP TABLE IF EXISTS cangku;
CREATE TABLE `cangku` (
  `PID` VARCHAR(10),
  `PNUM` VARCHAR(10) NOT NULL,
  `SID` VARCHAR(10) NOT NULL
)

INSERT INTO `cangku`
VALUES
  ('1', '10', '01'),
  ('1', '12', '02'),
  ('2', '8', '01'),
  ('3', '11', '01'),
  ('3', '8', '03');

-- 行转列，列转行
SELECT * FROM cangku;

SELECT `PID`,
	MAX(CASE `SID` WHEN '01' THEN `PNUM` ELSE 0 END) AS 'SID01',
	MAX(CASE `SID` WHEN '02' THEN `PNUM` ELSE 0 END) AS 'SID02',
	MAX(CASE `SID` WHEN '03' THEN `PNUM` ELSE 0 END) AS 'SID03'
FROM `cangku`
GROUP BY `PID`;
```



### 1.1 行转列+统计

原数据：

![image-20220209201612109](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20220209201613.png)

行转列+统计后：

![image-20220209201628369](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20220209201629.png)

```mysql
CREATE TABLE `userinfo` (
  `id` int(11) NOT NULL COMMENT '主键',
  `name` varchar(20) DEFAULT NULL COMMENT '姓名',
  `sex` varchar(3) DEFAULT NULL COMMENT '性别',
  `no` int(11) DEFAULT NULL COMMENT '编号',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='学生表';

INSERT INTO `userinfo` (`id`, `name`, `sex`, `no`)
VALUES ('1', '张三', '男', '1'),
       ('2', '李四', '男', '2'),
       ('3', '王五', '女', '1');

#方式1: CASE 列 WHEN 行 (需要临时表将统计字段计算出来)
SELECT `no` AS '编号',
       sum(CASE sex WHEN '男' THEN `count` ELSE 0 END) AS '男生',
       sum(CASE sex WHEN '女' THEN `count` ELSE 0 END) AS '女生'
FROM (SELECT `no`, sex, count(*) AS `count` FROM userinfo GROUP BY `no`, sex) tmp
GROUP BY `no`;

#方式2: 连表直接查询
SELECT `no` AS '编号',
       (SELECT count(*) FROM userinfo u2 WHERE u1.`no`=u2.`no` AND u2.sex='男') AS '男生',
       (SELECT count(*) FROM userinfo u2 WHERE u1.`no`=u2.`no` AND u2.sex='女') AS '女生'
FROM userinfo u1
GROUP BY `no`;

#方式1 与 方式2 在性能差异上并不大，暂无实测大量数据。
```



### 2. 保留最小ID删除重复值

```mysql
# 查询表中重复数据，删除重复数据，保留id最小的数据 #
DROP TABLE IF EXISTS team;

CREATE TABLE team (
  id INT PRIMARY KEY AUTO_INCREMENT,
  NAME VARCHAR (20)
) CHARSET = utf8;

INSERT INTO team (`name`)
VALUES ('a'), ('b'), ('b'), ('a'), ('c'), ('c');

-- 原始：
-- id name
--  1   a
--  2   b
--  3   b
--  4   a
--  5   c
--  6   c
-- 效果：
-- id name
--  1   a
--  2   b
--  5   c

-- 查询显示重复的数据都是显示最前面的几条，因此不需要查询是否最小值
DELETE FROM team WHERE `name` IN(
  SELECT `name` FROM (
    SELECT `name` FROM team GROUP BY `name` HAVING COUNT(`name`) > 1
  ) e
) AND id NOT IN (
  SELECT id FROM (
    # 此处的 HAVING 可省略，添加有助于提升过滤数据效率 #
    SELECT MIN(id) AS id FROM team GROUP BY `name` HAVING COUNT(`name`) > 1
  ) t
)
```



### 3. 过滤数据到新表

```mysql
DROP TABLE IF EXISTS `C`;

CREATE TABLE `C` (
  `CID` VARCHAR (100) NOT NULL,
  `Name` VARCHAR (50) DEFAULT NULL,
  `Class` VARCHAR (20) DEFAULT NULL,
  `Score` INT (11) DEFAULT NULL,
  PRIMARY KEY (`CID`)
) ENGINE = INNODB DEFAULT CHARSET = utf8;

DROP TABLE IF EXISTS `Score`;

CREATE TABLE `Score` (
  `Sid` INT (11) NOT NULL AUTO_INCREMENT,
  `Class` VARCHAR (10) DEFAULT NULL,
  `Score` INT (11) DEFAULT NULL,
  PRIMARY KEY (`Sid`)
) ENGINE = INNODB AUTO_INCREMENT = 5 DEFAULT CHARSET = utf8;

/*Data for the table `Score` */
INSERT INTO `Score` (`Sid`, `Class`, `Score`)
VALUES
  (1, '数学', 80),
  (2, '计算机', 59),
  (3, '计算机', 60),
  (4, '数学', 55);

DROP TABLE IF EXISTS `Student`;

CREATE TABLE `Student` (
  `Sid` INT (11) NOT NULL AUTO_INCREMENT,
  `Name` VARCHAR (10) DEFAULT NULL,
  `Age` INT (11) DEFAULT NULL,
  PRIMARY KEY (`Sid`)
) ENGINE = INNODB AUTO_INCREMENT = 6 DEFAULT CHARSET = utf8;

/*Data for the table `Student` */
INSERT INTO `Student` (`Sid`, `Name`, `Age`)
VALUES
  (1, '张三', 11),
  (2, '赵四', 22),
  (3, '张飞', 33),
  (4, '李武', 22),
  (5, NULL, 11);

-- 1.取出Name，Class，Score
SELECT `Name`, Class, Score FROM Student
LEFT JOIN Score ON Score.`Sid`=Student.`Sid`

-- 2.取出考试成绩不合格的学生
SELECT st.Sid, st.`Name`, sc.Score FROM Student AS st
LEFT JOIN Score AS sc ON sc.`Sid`=st.`Sid`
WHERE sc.`Score` < 60

-- 3.删除表A中没有考试成绩的学生记录
DELETE FROM Student WHERE Sid IN(
  SELECT Sid FROM (
    SELECT st.`Sid` FROM Student AS st
    LEFT JOIN Score AS sc ON st.`Sid`=sc.`Sid`
    WHERE sc.`Score` < 60
  ) AS s
)

-- 4.将表A 和 表B的不合格记录移至表C
INSERT INTO C (C.`CID`, `Name`, Class, Score)
  SELECT REPLACE(UUID(), "-", "") AS Cid, `Name`, Class, Score FROM Student
  LEFT JOIN Score ON Student.`Sid` = Score.`Sid`
  WHERE Score.`Score` < 60
```



### 4. 连表查询 × 50

````sql
-- 建表
-- 学生表
DROP TABLE IF EXISTS Student;

CREATE TABLE `Student` (
  `s_id` VARCHAR (20) NOT NULL COMMENT '学生id',
  `s_name` VARCHAR (20) DEFAULT NULL COMMENT '学生姓名',
  `s_birth` VARCHAR (20) DEFAULT NULL COMMENT '学生生日',
  `s_sex` VARCHAR (10) DEFAULT NULL COMMENT '学生性别',
  PRIMARY KEY (`s_id`)
);

-- 课程表
 DROP TABLE IF EXISTS Course;

CREATE TABLE `Course` (
  `c_id` VARCHAR (20) NOT NULL COMMENT '课程id',
  `c_name` VARCHAR (20) DEFAULT NULL COMMENT '课程名称',
  `t_id` VARCHAR (20) DEFAULT NULL COMMENT '老师id',
  PRIMARY KEY (`c_id`)
);

-- 教师表
 DROP TABLE IF EXISTS Teacher;

CREATE TABLE `Teacher` (
  `t_id` VARCHAR (20) NOT NULL COMMENT '老师id',
  `t_name` VARCHAR (20) DEFAULT NULL COMMENT '老师姓名',
  PRIMARY KEY (`t_id`)
);

-- 成绩表
 DROP TABLE IF EXISTS Score;

CREATE TABLE `Score` (
  `s_id` VARCHAR (20) NOT NULL COMMENT '成绩id',
  `c_id` VARCHAR (20) NOT NULL COMMENT '课程id',
  `s_score` INT (3) DEFAULT NULL COMMENT '成绩分数',
  PRIMARY KEY (`s_id`, `c_id`)
);

-- 插入学生表测试数据
insert into Student values('01' , '赵雷' , '1990-01-01' , '男');
insert into Student values('02' , '钱电' , '1990-12-21' , '男');
insert into Student values('03' , '孙风' , '1990-05-20' , '男');
insert into Student values('04' , '李云' , '1990-08-06' , '男');
insert into Student values('05' , '周梅' , '1991-12-01' , '女');
insert into Student values('06' , '吴兰' , '1992-03-01' , '女');
insert into Student values('07' , '郑竹' , '1989-07-01' , '女');
insert into Student values('08' , '王菊' , '1990-01-20' , '女');

-- 课程表测试数据
insert into Course values('01' , '语文' , '02');
insert into Course values('02' , '数学' , '01');
insert into Course values('03' , '英语' , '03');

-- 教师表测试数据
insert into Teacher values('01' , '张三');
insert into Teacher values('02' , '李四');
insert into Teacher values('03' , '王五');

-- 成绩表测试数据
insert into Score values('01' , '01' , 80);
insert into Score values('01' , '02' , 90);
insert into Score values('01' , '03' , 99);
insert into Score values('02' , '01' , 70);
insert into Score values('02' , '02' , 60);
insert into Score values('02' , '03' , 80);
insert into Score values('03' , '01' , 80);
insert into Score values('03' , '02' , 80);
insert into Score values('03' , '03' , 80);
insert into Score values('04' , '01' , 50);
insert into Score values('04' , '02' , 30);
insert into Score values('04' , '03' , 20);
insert into Score values('05' , '01' , 76);
insert into Score values('05' , '02' , 87);
insert into Score values('06' , '01' , 31);
insert into Score values('06' , '03' , 34);
insert into Score values('07' , '02' , 89);
insert into Score values('07' , '03' , 98);
````

![image-20200813081042896](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20200813081044.png)

![image-20200813081157306](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20200813081158.png)

![image-20200813081250445](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20200813081251.png)

![image-20200813081313660](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20200813081314.png)



````mysql
-- 1.学生表
-- student(s_id,s_name,s_birth,s_sex) –学生编号,学生姓名, 出生年月,学生性别
-- 2.课程表
-- course(c_id,c_name,t_id) – –课程编号, 课程名称, 教师编号
-- 3.教师表
-- teacher(t_id,t_name) –教师编号,教师姓名
-- 4.成绩表
-- score(s_id,c_id,s_score) –学生编号,课程编号,分数

-- 1、查询"01"课程比"02"课程成绩高的学生的信息及课程分数
SELECT st.*, sc1.s_score, sc2.s_score, co.c_name FROM student AS st
         INNER JOIN score AS sc1 ON st.s_id = sc1.s_id AND sc1.c_id = '01'
         INNER JOIN score AS sc2 ON st.s_id = sc2.s_id AND sc2.c_id = '02'
         INNER JOIN course AS co ON sc1.c_id = co.c_id
WHERE sc1.s_score > sc2.s_score;

-- 2、查询"01"课程比"02"课程成绩低的学生的信息及课程分数
SELECT st.*, sc1.s_score, sc2.s_score, co.c_name FROM student AS st
         INNER JOIN score AS sc1 ON st.s_id = sc1.s_id AND sc1.c_id = '01'
         INNER JOIN score AS sc2 ON st.s_id = sc2.s_id AND sc2.c_id = '02'
         INNER JOIN course AS co ON sc1.c_id = co.c_id
WHERE sc1.s_score < sc2.s_score;

-- 3、查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩
SELECT st.s_id, st.s_name, AVG(sc.s_score) avgScore FROM student AS st
         LEFT JOIN score AS sc ON sc.s_id = st.s_id
GROUP BY st.s_id
HAVING avgScore >= 60;

-- 4、查询平均成绩小于60分的同学的学生编号和学生姓名和平均成绩
-- (包括有成绩的和无成绩的)
SELECT st.s_id, st.s_name, AVG(sc.s_score) avgScore FROM student AS st
         LEFT JOIN score AS sc ON sc.s_id = st.s_id
GROUP BY st.s_id HAVING avgScore < 60 OR avgScore IS NULL;

-- 5、查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩
SELECT st.s_id, st.s_name, COUNT(co.c_id) AS count, SUM(sc.s_score) AS sum FROM student AS st
         LEFT JOIN score AS sc ON sc.s_id = st.s_id
         LEFT JOIN course AS co ON co.c_id = sc.c_id
GROUP BY st.s_id;

-- 6、查询"李"姓老师的数量
SELECT COUNT(t.t_id) FROM teacher AS t
WHERE t.t_name LIKE '李%';

-- 7、查询学过"张三"老师授课的同学的信息
SELECT st.*, te.t_name FROM student AS st
         LEFT JOIN score AS sc ON sc.s_id = st.s_id
         LEFT JOIN course AS co ON co.c_id = sc.c_id
         LEFT JOIN teacher AS te ON te.t_id = co.t_id
WHERE te.t_name = '张三';

-- 8、查询没学过"张三"老师授课的同学的信息
SELECT st.*, te.t_name FROM student AS st
         LEFT JOIN score AS sc ON sc.s_id = st.s_id
         LEFT JOIN course AS co ON co.c_id = sc.c_id
         LEFT JOIN teacher AS te ON te.t_id = co.t_id
WHERE te.t_name != '张三';

-- 9、查询学过编号为"01"并且也学过编号为"02"的课程的同学的信息
SELECT st.*, sc.c_id FROM student AS st
         LEFT JOIN score AS sc ON sc.s_id = st.s_id
WHERE sc.c_id IN ('01', '02');

-- 10、查询学过编号为"01"但是没有学过编号为"02"的课程的同学的信息
SELECT st.s_id, st.s_name, st.s_sex, st.s_birth, sc1.c_id FROM student AS st
         LEFT JOIN (SELECT * FROM score WHERE c_id = '01') AS sc1 ON sc1.s_id = st.s_id
         LEFT JOIN (SELECT * FROM score WHERE c_id = '02') AS sc2 ON sc2.s_id = st.s_id
WHERE sc1.c_id = '01'
  AND sc2.c_id IS NULL;

-- 11、查询没有学全所有课程的同学的信息
SELECT st.*, COUNT(c_id) AS num FROM student AS st #分组统计每个学生的课程数,不等于总可成熟
         LEFT JOIN score sc ON st.s_id = sc.s_id
GROUP BY sc.s_id
HAVING num != (SELECT COUNT(c_id) FROM course); #查询课程的总数

-- 12、查询至少有一门课与学号为"01"的同学所学相同的同学的信息
SELECT st.*, tmp.c_id FROM student AS st,
     ( #查询分数表中在01课程id内的学生id
         SELECT DISTINCT sc.s_id, sc.c_id FROM score AS sc
         WHERE c_id IN ( #学生01学过的课程id
             SELECT c_id FROM score WHERE s_id = '01'
         )
     ) AS tmp
WHERE st.s_id = tmp.s_id;

-- 13、查询和"01"号的同学学习的课程完全相同的其他同学的信息
SELECT st.* FROM student AS st
WHERE st.s_id IN ( #查询分数表里与01一样的分数个数的学生id(排除01)
    SELECT s_id FROM score
    WHERE s_id != '01'
      AND c_id IN ( #查询01同学的课程id
        SELECT c_id FROM score WHERE s_id = '01'
    )
    GROUP BY s_id
    HAVING COUNT(*) = ( #查询01同学学过课程个数
        SELECT COUNT(*) FROM score WHERE s_id = '01'
    )
);

-- 14、查询没学过"张三"老师讲授的任一门课程的学生姓名
SELECT st.* FROM student AS st
WHERE st.s_id NOT IN ( #查询学过张三老师对应课程的学生id
    SELECT sc.s_id FROM score AS sc
    WHERE sc.c_id IN ( #查询张三老师教的课程id
        SELECT co.c_id FROM course AS co, teacher AS te
        WHERE co.t_id = te.t_id AND te.t_name = '张三'
    )
);

-- 15、查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩
SELECT st.s_id, st.s_name, count(*) failCount, avg(sc.s_score) avg FROM score sc
         LEFT JOIN student st ON sc.s_id = st.s_id
WHERE sc.s_score < 60 #先查不及格的数量>2的学生id
GROUP BY sc.s_id HAVING failCount >= 2;

-- 16、检索"01"课程分数小于60，按分数降序排列的学生信息
SELECT st.*, sc.s_score FROM score sc
         LEFT JOIN student st ON sc.s_id = st.s_id
WHERE sc.c_id = '01' AND sc.s_score < 60
ORDER BY sc.s_score DESC;

-- 17、按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩
SELECT st.*, sc.s_score, t.avg FROM student st
        LEFT JOIN score sc ON sc.s_id = st.s_id
        LEFT JOIN (SELECT s_id, avg(s_score) avg FROM score GROUP BY s_id) t ON t.s_id = st.s_id
ORDER BY avg DESC;

-- 18.查询各科成绩最高分、最低分和平均分：以如下形式显示：课程ID，课程name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率
-- 及格为>=60，中等为：70-80，优良为：80-90，优秀为：>=90
SELECT c.c_id, c.c_name, MAX(sc.s_score) "最高分", MIN(sc.s_score) "最低分", AVG(sc.s_score) "平均分"
     ,((SELECT COUNT(s_id) FROM score WHERE s_score>=60 AND c_id=c.c_id )/(SELECT COUNT(s_id) FROM score WHERE c_id=c.c_id)) "及格率"
     ,((SELECT COUNT(s_id) FROM score WHERE s_score>=70 AND s_score<80 AND c_id=c.c_id )/(SELECT COUNT(s_id) FROM score WHERE c_id=c.c_id)) "中等率"
     ,((SELECT COUNT(s_id) FROM score WHERE s_score>=80 AND s_score<90 AND c_id=c.c_id )/(SELECT COUNT(s_id) FROM score WHERE c_id=c.c_id)) "优良率"
     ,((SELECT COUNT(s_id) FROM score WHERE s_score>=90 AND c_id=c.c_id )/(SELECT COUNT(s_id) FROM score WHERE c_id=c.c_id)) "优秀率"
FROM course c
         LEFT JOIN score sc ON sc.c_id=c.c_id
GROUP BY c.c_id;

-- 19、按各科成绩进行排序，并显示排名
SET @rank = 0;
SELECT sc.*, @rank := @rank + 1 AS r FROM score sc
ORDER BY sc.s_score;

-- 20、查询学生的总成绩并进行排名
SET @rank = 0;
SELECT a.*, @rank := @rank + 1 AS r
FROM (SELECT sc.*, sum(sc.s_score) scoreSum FROM score sc
      GROUP BY s_id
      ORDER BY scoreSum DESC) AS a;

-- 21、查询不同老师所教不同课程平均分从高到低显示
SELECT
    t.t_id AS 老师ID,
    t.t_name AS 老师姓名,
    c.c_id AS 课程ID,
    c.c_name AS 课程名称,
    ROUND(AVG(s.s_score), 2) AS 课程平均分
FROM Teacher t
JOIN Course c ON t.t_id = c.t_id
JOIN Score s ON c.c_id = s.c_id
GROUP BY t.t_id, t.t_name, c.c_id, c.c_name
ORDER BY 课程平均分 DESC;

-- 22、查询所有课程的成绩第2名到第3名的学生信息及该课程成绩
-- 先为每门课程的成绩排名，再筛选2-3名
SELECT
    st.s_id AS 学生ID,
    st.s_name AS 学生姓名,
    st.s_sex AS 学生性别,
    c.c_name AS 课程名称,
    sr.s_score AS 成绩,
    sr.rk AS 排名
FROM (
    SELECT
        sc.s_id,
        sc.c_id,
        sc.s_score,
        -- 用变量实现按课程分区排名（核心逻辑）
        @rk := IF(@pre_cid = sc.c_id, @rk + 1, 1) AS rk,
        @pre_cid := sc.c_id  -- 记录上一个课程ID，用于分区
    FROM Score sc,
    -- 初始化变量（必须放在这里）
    (SELECT @pre_cid := '', @rk := 0) AS temp
    -- 先按课程ID分组，再按成绩降序排序（排名的关键前提）
    ORDER BY sc.c_id, sc.s_score DESC
) AS sr
-- 关联学生表和课程表获取完整信息
JOIN Student st ON sr.s_id = st.s_id
JOIN Course c ON sr.c_id = c.c_id
-- 筛选第2、3名
WHERE sr.rk IN (2, 3)
-- 最终排序：按课程、按排名
ORDER BY c.c_id, sr.rk;

-- 23、统计各科成绩各分数段人数：课程编号,课程名称,[100-85],[85-70],[70-60],[0-60]及所占百分比
SELECT
    c.c_id AS 课程编号,
    c.c_name AS 课程名称,
    -- 各分数段人数
    SUM(CASE WHEN s.s_score BETWEEN 85 AND 100 THEN 1 ELSE 0 END) AS `100-85`,
    SUM(CASE WHEN s.s_score BETWEEN 70 AND 84 THEN 1 ELSE 0 END) AS `85-70`,
    SUM(CASE WHEN s.s_score BETWEEN 60 AND 69 THEN 1 ELSE 0 END) AS `70-60`,
    SUM(CASE WHEN s.s_score BETWEEN 0 AND 59 THEN 1 ELSE 0 END) AS `0-60`,
    -- 各分数段百分比（保留2位小数）
    ROUND(SUM(CASE WHEN s.s_score BETWEEN 85 AND 100 THEN 1 ELSE 0 END)/COUNT(s.s_score)*100,2) AS `100-85占比(%)`,
    ROUND(SUM(CASE WHEN s.s_score BETWEEN 70 AND 84 THEN 1 ELSE 0 END)/COUNT(s.s_score)*100,2) AS `85-70占比(%)`,
    ROUND(SUM(CASE WHEN s.s_score BETWEEN 60 AND 69 THEN 1 ELSE 0 END)/COUNT(s.s_score)*100,2) AS `70-60占比(%)`,
    ROUND(SUM(CASE WHEN s.s_score BETWEEN 0 AND 59 THEN 1 ELSE 0 END)/COUNT(s.s_score)*100,2) AS `0-60占比(%)`
FROM Course c
JOIN Score s ON c.c_id = s.c_id
GROUP BY c.c_id, c.c_name;

-- 24、查询学生平均成绩及其名次
SELECT
    sa.s_id AS 学生ID,
    sa.s_name AS 学生姓名,
    sa.平均成绩,
    @rank := @rank + 1 AS 名次
FROM (
    SELECT
        s.s_id,
        s.s_name,
        ROUND(AVG(sc.s_score), 2) AS 平均成绩
    FROM Student s
    JOIN Score sc ON s.s_id = sc.s_id
    GROUP BY s.s_id, s.s_name
    ORDER BY 平均成绩 DESC
) AS sa,
(SELECT @rank := 0) AS temp;

-- 25、查询各科成绩前三名的记录
SELECT
    st.s_id AS 学生ID,
    st.s_name AS 学生姓名,
    c.c_name AS 课程名称,
    sr.s_score AS 成绩,
    sr.rk AS 排名
FROM (
    SELECT
        sc.s_id,
        sc.c_id,
        sc.s_score,
        @rk := IF(@pre_cid = sc.c_id, @rk + 1, 1) AS rk,
        @pre_cid := sc.c_id
    FROM Score sc,
    (SELECT @pre_cid := '', @rk := 0) AS temp
    ORDER BY sc.c_id, sc.s_score DESC
) AS sr
JOIN Student st ON sr.s_id = st.s_id
JOIN Course c ON sr.c_id = c.c_id
WHERE sr.rk <= 3
ORDER BY c.c_id, sr.rk;


-- 26、查询每门课程被选修的学生数
SELECT
    c.c_id AS 课程编号,
    c.c_name AS 课程名称,
    COUNT(DISTINCT sc.s_id) AS 选修学生数
FROM Course c
LEFT JOIN Score sc ON c.c_id = sc.c_id
GROUP BY c.c_id, c.c_name;

-- 27、查询出只有两门课程的全部学生的学号和姓名
SELECT
    s.s_id AS 学生ID,
    s.s_name AS 学生姓名
FROM Student s
JOIN Score sc ON s.s_id = sc.s_id
GROUP BY s.s_id, s.s_name
HAVING COUNT(DISTINCT sc.c_id) = 2;

-- 28、查询男生、女生人数
SELECT
    s_sex AS 性别,
    COUNT(*) AS 人数
FROM Student
GROUP BY s_sex;

-- 29、查询名字中含有"风"字的学生信息
SELECT * FROM Student WHERE s_name LIKE '%风%';

-- 30、查询同名同性学生名单，并统计同名人数，
SELECT
    IFNULL(s.s_id, '无') AS 学生ID,
    IFNULL(s.s_name, '无同名同性学生') AS 学生姓名,
    IFNULL(s.s_sex, '') AS 性别,
    IFNULL(nsc.同名人数, 0) AS 同名人数
FROM (
    SELECT
        s_name,
        s_sex,
        COUNT(*) AS 同名人数
    FROM Student
    GROUP BY s_name, s_sex
    HAVING COUNT(*) > 1
) AS nsc
LEFT JOIN Student s ON s.s_name = nsc.s_name AND s.s_sex = nsc.s_sex
UNION ALL
-- 无重复时补充一行提示
SELECT '无', '无同名同性学生', '', 0
FROM DUAL
WHERE NOT EXISTS (
    SELECT 1 FROM Student GROUP BY s_name, s_sex HAVING COUNT(*) > 1
);

-- 31、查询1990年出生的学生名单
SELECT * FROM Student WHERE s_birth LIKE '1990-%';

-- 32、查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列
SELECT
    c.c_id AS 课程编号,
    c.c_name AS 课程名称,
    ROUND(AVG(sc.s_score), 2) AS 平均成绩
FROM Course c
JOIN Score sc ON c.c_id = sc.c_id
GROUP BY c.c_id, c.c_name
ORDER BY 平均成绩 DESC, c.c_id ASC;

-- 33、查询平均成绩大于等于85的所有学生的学号、姓名和平均成绩
SELECT
    s.s_id AS 学生ID,
    s.s_name AS 学生姓名,
    ROUND(AVG(sc.s_score), 2) AS 平均成绩
FROM Student s
JOIN Score sc ON s.s_id = sc.s_id
GROUP BY s.s_id, s.s_name
HAVING AVG(sc.s_score) >= 85;

-- 34、查询课程名称为"数学"，且分数低于60的学生姓名和分数
SELECT
    s.s_name AS 学生姓名,
    sc.s_score AS 分数
FROM Student s
JOIN Score sc ON s.s_id = sc.s_id
JOIN Course c ON sc.c_id = c.c_id
WHERE c.c_name = '数学' AND sc.s_score < 60;

-- 35、查询所有学生的课程及分数情况；
SELECT
    s.s_id AS 学生ID,
    s.s_name AS 学生姓名,
    c.c_name AS 课程名称,
    IFNULL(sc.s_score, '无成绩') AS 分数
FROM Student s
CROSS JOIN Course c
LEFT JOIN Score sc ON s.s_id = sc.s_id AND c.c_id = sc.c_id
ORDER BY s.s_id, c.c_id;

-- 36、查询任何一门课程成绩在70分以上的姓名、课程名称和分数
SELECT
    s.s_name AS 学生姓名,
    c.c_name AS 课程名称,
    sc.s_score AS 分数
FROM Student s
JOIN Score sc ON s.s_id = sc.s_id
JOIN Course c ON sc.c_id = c.c_id
WHERE sc.s_score > 70
ORDER BY s.s_name, c.c_name;

-- 37、查询不及格的课程
SELECT
    s.s_id AS 学生ID,
    s.s_name AS 学生姓名,
    c.c_name AS 课程名称,
    sc.s_score AS 分数
FROM Student s
JOIN Score sc ON s.s_id = sc.s_id
JOIN Course c ON sc.c_id = c.c_id
WHERE sc.s_score < 60
ORDER BY c.c_name, sc.s_score;

-- 38、查询课程编号为01且课程成绩在80分以上的学生的学号和姓名
SELECT
    s.s_id AS 学生ID,
    s.s_name AS 学生姓名
FROM Student s
JOIN Score sc ON s.s_id = sc.s_id
WHERE sc.c_id = '01' AND sc.s_score >= 80;

-- 39、求每门课程的学生人数
SELECT
    c.c_id AS 课程编号,
    c.c_name AS 课程名称,
    COUNT(DISTINCT sc.s_id) AS 学生人数
FROM Course c
LEFT JOIN Score sc ON c.c_id = sc.c_id
GROUP BY c.c_id, c.c_name;

-- 40、查询选修"张三"老师所授课程的学生中，成绩最高的学生信息及其成绩
SELECT
    st.s_id AS 学生ID,
    st.s_name AS 学生姓名,
    st.s_birth AS 生日,
    st.s_sex AS 性别,
    c.c_name AS 课程名称,
    sr.s_score AS 最高成绩
FROM (
    SELECT
        sc.s_id,
        sc.c_id,
        sc.s_score,
        @rk := IF(@pre_cid = sc.c_id, @rk + 1, 1) AS rk,
        @pre_cid := sc.c_id
    FROM (
        -- 先筛选张三老师的课程成绩并排序（独立子查询避免优化器干扰）
        SELECT sc.s_id, sc.c_id, sc.s_score
        FROM Score sc
        JOIN Course c ON sc.c_id = c.c_id
        JOIN Teacher t ON c.t_id = t.t_id
        WHERE t.t_name = '张三'
        ORDER BY sc.c_id, sc.s_score DESC
    ) AS sc,
    (SELECT @pre_cid := '', @rk := 0) AS temp
) AS sr
JOIN Student st ON sr.s_id = st.s_id
JOIN Course c ON sr.c_id = c.c_id
WHERE sr.rk = 1;

-- 41、查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩
SELECT
    sc1.s_id AS 学生ID,
    sc1.c_id AS 课程1编号,
    sc2.c_id AS 课程2编号,
    sc1.s_score AS 成绩
FROM Score sc1
JOIN Score sc2 ON sc1.s_id = sc2.s_id 
               AND sc1.c_id <> sc2.c_id 
               AND sc1.s_score = sc2.s_score
ORDER BY sc1.s_id, sc1.s_score;

-- 42、查询每门功成绩最好的前两名
SELECT
    st.s_id AS 学生ID,
    st.s_name AS 学生姓名,
    c.c_name AS 课程名称,
    sr.s_score AS 成绩,
    sr.rk AS 排名
FROM (
    SELECT
        sc.s_id,
        sc.c_id,
        sc.s_score,
        @rk := IF(@pre_cid = sc.c_id, @rk + 1, 1) AS rk,
        @pre_cid := sc.c_id
    FROM Score sc,
    (SELECT @pre_cid := '', @rk := 0) AS temp
    ORDER BY sc.c_id, sc.s_score DESC
) AS sr
JOIN Student st ON sr.s_id = st.s_id
JOIN Course c ON sr.c_id = c.c_id
WHERE sr.rk <= 2
ORDER BY c.c_id, sr.rk;

-- 43、统计每门课程的学生选修人数（超过5人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列
SELECT
    c.c_id AS 课程编号,
    COUNT(DISTINCT sc.s_id) AS 选修人数
FROM Course c
JOIN Score sc ON c.c_id = sc.c_id
GROUP BY c.c_id
HAVING COUNT(DISTINCT sc.s_id) > 5
ORDER BY 选修人数 DESC, c.c_id ASC;

-- 44、检索至少选修两门课程的学生学号
SELECT s_id AS 学生ID
FROM Score
GROUP BY s_id
HAVING COUNT(DISTINCT c_id) >= 2;

-- 45、查询选修了全部课程的学生信息
SELECT s.*
FROM Student s
JOIN Score sc ON s.s_id = sc.s_id
GROUP BY s.s_id, s.s_name, s.s_birth, s.s_sex
HAVING COUNT(DISTINCT sc.c_id) = (SELECT COUNT(*) FROM Course);

-- 46、查询各学生的年龄
SELECT
    s_id AS 学生ID,
    s_name AS 学生姓名,
    YEAR(NOW()) - YEAR(STR_TO_DATE(s_birth, '%Y-%m-%d')) AS 年龄
FROM Student;

-- 47、查询本周过生日的学生
-- 真实时间
SELECT *
FROM Student
WHERE 
    -- 提取生日的月-日，转换为当年日期
    STR_TO_DATE(CONCAT(YEAR(NOW()), '-', DATE_FORMAT(STR_TO_DATE(s_birth, '%Y-%m-%d'), '%m-%d')), '%Y-%m-%d')
    -- 判断是否在本周（周一到周日）
    BETWEEN DATE_SUB(CURDATE(), INTERVAL WEEKDAY(CURDATE()) DAY)
    AND DATE_ADD(CURDATE(), INTERVAL 6 - WEEKDAY(CURDATE()) DAY);
-- 限定时间
SELECT *
FROM Student
WHERE 
    STR_TO_DATE(CONCAT('1990', '-', DATE_FORMAT(STR_TO_DATE(s_birth, '%Y-%m-%d'), '%m-%d')), '%Y-%m-%d')
    BETWEEN '1990-01-01' AND '1990-01-07';

-- 48、查询下周过生日的学生
SELECT *
FROM Student
WHERE 
    DATE_FORMAT(STR_TO_DATE(s_birth, '%Y-%m-%d'), '%m-%d') 
    BETWEEN DATE_FORMAT(DATE_SUB(CURDATE(), INTERVAL WEEKDAY(CURDATE()) - 7 DAY), '%m-%d')
    AND DATE_FORMAT(DATE_ADD(CURDATE(), INTERVAL 6 - WEEKDAY(CURDATE()) + 7 DAY), '%m-%d');

-- 49、查询本月过生日的学生
-- 方式1：基础版（按系统当前月份查询）
SELECT *
FROM Student
WHERE MONTH(STR_TO_DATE(s_birth, '%Y-%m-%d')) = MONTH(NOW());

-- 方式2：固定测试版（强制查询1月过生日的学生，直接验证结果）
-- （手动指定月份为1，可查到赵雷、王菊等1月生日的学生）
SELECT *
FROM Student
WHERE MONTH(STR_TO_DATE(s_birth, '%Y-%m-%d')) = 1;

-- 50、查询下月过生日的学生
-- 注意:当 当前月为12时,用month(now())+1为13而不是1,可用timestampadd()函数或mod取模
SELECT *
FROM Student
WHERE 
    MONTH(STR_TO_DATE(s_birth, '%Y-%m-%d')) = 
    MONTH(DATE_ADD(NOW(), INTERVAL 1 MONTH));
````

