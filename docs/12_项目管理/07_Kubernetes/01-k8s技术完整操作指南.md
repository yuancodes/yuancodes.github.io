---
title: 01-k8s技术完整操作指南
date: 2025-08-09 22:33:12
index_img: https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20250715161022.png
tags:
- Kubernetes
- k8s
- Docker
categories: 
- 12_项目管理
- 07_Kubernetes
---

![Kubernetes 介绍 - Session的专栏 - TNBLOG](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20250715161022.png)

参考资料：https://kubernetes.io/zh-cn/



## 1. Docker基础介绍与实施步骤

### 1.1 什么是Docker？

Docker是一种开源的容器化平台，允许开发者将应用程序及其所有依赖打包到一个轻量级、可移植的容器中。容器确保应用在任何环境中都能一致地运行，无论是在开发、测试还是生产环境。

### 1.2 为什么使用Docker？

* **一致性**：消除“在我的机器上可以运行”的问题。
* **可移植性**：容器可以在任何支持Docker的环境中运行。
* **资源高效**：相比传统的虚拟机，容器更轻量，启动更快。
* **隔离性**：每个容器运行在独立的环境中，避免相互干扰。

### 1.3 Docker安装步骤

根据不同的操作系统，Docker的安装步骤有所不同。以下分别介绍在Windows、MacOS和Linux上的安装方法。

#### 1.3.1 在Windows上安装Docker

1. 系统要求：
   * Windows 10 64-bit: Pro, Enterprise, or Education (Build 15063 or later)。
   * 确保已启用**Hyper-V**和**容器**功能。

2. 下载Docker Desktop：访问[Docker官网](https://www.docker.com/products/docker-desktop/)下载适用于Windows的Docker Desktop安装程序。

3. 安装Docker Desktop：

   * 双击下载的安装程序，按照提示完成安装。
   * 安装完成后，重启计算机（如果提示）。

4. 验证安装：

   打开命令提示符（CMD）或PowerShell，运行：

   ```bash
   docker --version
   ```

   预期输出：

   ```
   Docker version 20.10.7, build f0df350
   ```

   

#### 1.3.2 在MacOS上安装Docker

1. 系统要求：
   * MacOS 10.14 或更高版本。
   * 至少4GB的RAM。

2. 下载Docker Desktop：

   * 访问[Docker官网](https://www.docker.com/products/docker-desktop/)下载适用于MacOS的Docker Desktop安装程序。

3. 安装Docker Desktop：

   * 双击下载的`.dmg`文件，将Docker图标拖拽到“Applications”文件夹中。

4. 启动Docker Desktop：

   * 在“Applications”文件夹中找到Docker图标，双击启动。
   * 安装完成后，Docker图标会显示在菜单栏中。

5. 验证安装：

   * 打开终端，运行：

     ```bash
     docker --version
     ```

   * 预期输出：

     ```
     Docker version 20.10.7, build f0df350
     ```

     

#### 1.3.3 在Linux上安装Docker

以Ubuntu为例，介绍Docker的安装步骤。

1. 更新包索引并安装依赖：

   ```bash
   sudo apt-get update
   sudo apt-get install \
       ca-certificates \
       curl \
       gnupg \
       lsb-release
   ```

2. 添加Docker的官方GPG密钥：

   ```bash
   sudo mkdir -p /etc/apt/keyrings
   curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
   ```

3. 设置Docker的APT源：

   ```bash
   echo \
     "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
     $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
   ```

4. 安装Docker Engine：

   ```bash
   sudo apt-get update
   sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
   ```

5. 启动并启用Docker服务：

   ```
   sudo systemctl start docker
   sudo systemctl enable docker
   ```

6. 添加当前用户到docker组（可选，避免每次运行docker命令需sudo）：

   ```bash
   sudo usermod -aG docker $USER
   ```

   注意：运行上述命令后，需要重新登录或重启系统以使更改生效。

7. 验证安装：

   ```bash
   docker --version
   #预期输出
   Docker version 20.10.7, build f0df350
   ```

   

### 1.4 Docker基本操作步骤

#### 1.4.1 拉取镜像

Docker镜像是容器的蓝图，包含应用程序及其所有依赖。

**命令格式**：

```bash
docker pull <image-name>:<tag>
```

示例：拉取官方的Nginx镜像

```bash
docker pull nginx:latest
#预期输出
latest: Pulling from library/nginx
a3ab...: Already exists
Digest: sha256:...
Status: Downloaded newer image for nginx:latest
```

#### 1.4.2 运行容器

使用镜像创建并启动一个容器。

**命令格式**：

```bash
docker run -d --name <container-name> -p <host-port>:<container-port> <image-name>:<tag>
```

示例：运行一个Nginx容器，绑定本地的8080端口到容器的80端口

```bash
docker run -d --name my-nginx -p 8080:80 nginx:latest
```

参数说明：

```bash
-d：后台运行容器。
--name：为容器指定一个名称。
-p：端口映射，将主机的8080端口映射到容器的80端口。
```

预期输出：

```
a3ab... (容器ID)
```

验证运行：

打开浏览器，访问http://localhost:8080，应看到Nginx欢迎页面。



#### 1.4.3 查看运行中的容器

**命令格式**：

```bash
docker ps
#预期输出：
CONTAINER ID   IMAGE         COMMAND                  CREATED          STATUS          PORTS                  NAMES
a3ab...        nginx:latest  "/docker-entrypoint.…"   10 seconds ago   Up 9 seconds    0.0.0.0:8080->80/tcp   my-nginx
```




#### 1.4.4 查看容器日志

**命令格式**：

```bash
docker logs <container-name>
```


示例：

```bash
docker logs my-nginx
#预期输出：
172.17.0.1 - - [01/Jan/2024:12:00:00 +0000] "GET / HTTP/1.1" 200 612 "-" "curl/7.68.0"
```



#### 1.4.5 进入容器

**命令格式**：

```bash
docker exec -it <container-name> /bin/bash
```

示例：

```bash
docker exec -it my-nginx /bin/bash
```

说明：进入容器内部，可以执行命令和查看文件。



#### 1.4.6 停止和删除容器

**停止容器**：

```bash
docker stop <container-name>
```

示例：

```bash
docker stop my-nginx
#预期输出：
容器ID
```


**删除容器**：

```bash
docker rm <container-name>
```

示例：

```bash
docker rm my-nginx
#预期输出：
容器ID
```




#### 1.4.7 构建自定义镜像

1. **编写Dockerfile**

创建一个目录用于存放Dockerfile和相关文件，例如myapp：

```bash
mkdir myapp
cd myapp
```


Dockerfile内容（简单的Python应用示例）：

```dockerfile
# 使用官方Python基础镜像
FROM python:3.9-slim

# 设置工作目录
WORKDIR /app

# 复制当前目录内容到工作目录
COPY . /app

# 安装应用依赖
RUN pip install --no-cache-dir -r requirements.txt

# 暴露端口
EXPOSE 5000

# 定义环境变量
ENV NAME World

# 运行应用
CMD ["python", "app.py"]
```



2. **创建应用文件**

requirements.txt：

```txt
Flask
```

app.py：

```python
from flask import Flask
import os

app = Flask(__name__)

@app.route('/')
def hello():
    name = os.getenv('NAME', 'World')
    return f'Hello, {name}!'

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
```

3. **构建镜像**

```bash
docker build -t my-python-app:latest .
#预期输出：
Sending build context to Docker daemon  5.632kB
Step 1/6 : FROM python:3.9-slim
 ---> ...
Step 2/6 : WORKDIR /app
 ---> Using cache
 ---> ...
Step 3/6 : COPY . /app
 ---> Using cache
 ---> ...
Step 4/6 : RUN pip install --no-cache-dir -r requirements.txt
 ---> Using cache
 ---> ...
Step 5/6 : EXPOSE 5000
 ---> Using cache
 ---> ...
Step 6/6 : CMD ["python", "app.py"]
 ---> Using cache
 ---> ...
Successfully built ...
Successfully tagged my-python-app:latest
```



4. **运行自定义镜像**

```bash
docker run -d --name my-python-app -p 5000:5000 my-python-app:latest
#预期输出：
a3ab...
```



5. **验证应用**

打开浏览器，访问http://localhost:5000，应显示Hello, World!

通过环境变量修改问候语：

```bash
docker stop my-python-app
docker rm my-python-app
docker run -d --name my-python-app -p 5000:5000 -e NAME=Kubernetes my-python-app:latest
```

再次访问http://localhost:5000，应显示Hello, Kubernetes!

### 1.5 Docker常见问题及解决方案

问题1：**无法拉取镜像**

原因：

* 网络问题。
* 镜像名称或标签错误。

解决方案：

* 检查网络连接。
* 确认镜像名称和标签正确。
* 尝试使用不同的镜像仓库。

问题2：**容器启动失败**

原因：

* Dockerfile配置错误。
* 应用依赖未正确安装。

解决方案：

* 检查Dockerfile和应用日志。
* 确认所有依赖已正确安装。

问题3：**端口冲突**

原因：

* 主机端口已被其他应用占用。

解决方案：

* 更换主机端口，例如将-p 8080:80改为-p 8081:80。



## 2. Kubernetes基础概念与架构

### 2.1 Kubernetes概述

Kubernetes（简称K8s）是一个开源的容器编排平台，用于自动化部署、扩展和管理容器化应用。它提供了丰富的功能，如负载均衡、服务发现、自动伸缩、滚动更新等，帮助开发者和运维团队高效地管理大规模的应用部署。

**定义**：Kubernetes是一个用于自动部署、扩展和管理容器化应用的开源平台。

**历史背景**：由Google开发并开源，基于其内部的Borg系统，旨在简化大规模容器管理。

### 2.2 虚拟化与容器化的区别

虚拟化：

* 概念：通过虚拟机管理程序（如VMware、Hyper-V）在物理硬件上运行多个操作系统实例。

* 优点：隔离性强，每个虚拟机拥有独立的操作系统。

* 缺点：资源开销大，启动速度慢。

容器化：

* 概念：通过容器引擎（如Docker）在同一操作系统内核上运行多个隔离的应用实例。

* 优点：资源利用率高，启动速度快，便于部署和迁移。

* 缺点：隔离性不如虚拟机，依赖于宿主操作系统。

### 2.3 Kubernetes架构详解

Kubernetes的架构主要分为**控制平面（Control Plane）和节点（Node）**两大部分。

**控制平面（Control Plane）**

* API Server：
  * 功能：作为Kubernetes的控制中心，所有API请求都通过API Server处理。
  * 交互：与kubectl、其他Kubernetes组件和外部系统交互。
  * 安全性：支持认证、授权和审计，确保集群的安全性。
* Scheduler：
  * 功能：根据资源需求和调度策略，将Pod分配到合适的Node上。
  * 调度算法：考虑资源利用率、亲和性/反亲和性、污点和容忍等因素。
  * 扩展性：支持自定义调度器和调度插件，满足特定的调度需求。
* Controller Manager：
  * 功能：运行各种控制器，确保集群的期望状态与实际状态一致。

* 常见控制器：
  * ReplicaSet Controller：管理Pod的副本数量。
  * Deployment Controller：管理Deployment资源，支持滚动更新和回滚。
  * Node Controller：监控Node的状态，处理Node故障。
  * Endpoint Controller：管理Service的Endpoints，确保服务发现的准确性。
* etcd：
  * 功能：分布式键值存储，保存集群的状态数据。
  * 特性：分布式、高可用、强一致性，确保数据的可靠性和一致性。
  * 备份与恢复：定期备份etcd数据，确保在灾难发生时能够恢复集群状态。

**节点（Node）**

* Kubelet：
  * 功能：每个Node上的代理，负责Pod和容器的生命周期管理。
  * 任务：确保Pod按照定义运行，监控容器状态，报告Node状态。
  * 交互：与API Server通信，接收调度指令和更新信息。
* Kube-Proxy：
  * 功能：实现Kubernetes的网络服务，管理Service的负载均衡和网络路由。
  * 工作方式：基于iptables或IPVS，转发流量到对应的Pod。
  * 高可用性：在多个Node上运行，确保网络服务的可靠性。
* 容器运行时（Container Runtime）：
  * 定义：如Docker、containerd，负责运行容器。
  * 功能：下载镜像、运行容器、管理容器生命周期。

### 2.4 关键概念

* Pod：Kubernetes中最小的可部署单元，一个Pod可以包含一个或多个紧密关联的容器。
* Service：定义一组Pod的访问策略，提供负载均衡和服务发现功能。
* Deployment：管理Pod的部署和更新，支持滚动更新和回滚。
* Namespace：用于在同一个集群中划分多个虚拟子集，便于资源隔离和管理。

### 2.5 案例分析

案例1：电商平台的容器化部署

```txt
背景：一个电商平台包含前端、后端和数据库三个部分。传统部署中，这三个部分分别运行在不同的虚拟机上，资源利用率不高，且部署和扩展较为复杂。

容器化部署：
前端：使用Docker将前端应用打包成容器镜像，确保环境一致性。
后端：同样打包成容器镜像，方便与前端和数据库的协同工作。
数据库：运行在独立的数据库容器中，通过Kubernetes的Service进行访问。

Kubernetes管理：
Deployment：分别为前端和后端创建Deployment，管理其副本数量和更新策略。
Service：为前端和后端创建Service，提供内部负载均衡和服务发现。
Namespace：将电商平台的所有资源部署在一个独立的Namespace中，便于管理和监控。
```

案例2：多租户应用的资源隔离

```txt
背景：一家SaaS公司需要在同一个Kubernetes集群中为不同的客户提供服务，确保资源隔离和安全性。

解决方案：
Namespace划分：为每个客户创建独立的Namespace，隔离各自的资源和权限。
资源配额（Resource Quota）：为每个Namespace设置资源限制，防止资源滥用。
网络策略（Network Policy）：配置网络策略，控制不同Namespace之间的网络访问权限。
```



## 3. Kubernetes核心组件

### 3.1 API Server

- 功能：作为Kubernetes的控制中心，所有API请求都通过API Server处理。
- 交互：与kubectl、其他Kubernetes组件和外部系统交互。
- 安全性：支持认证、授权和审计，确保集群的安全性。

### 3.2 etcd

- 功能：保存Kubernetes集群的所有状态信息，是集群的“单一真理来源”。
- 特性：分布式、高可用、强一致性，确保数据的可靠性和一致性。
- 备份与恢复：定期备份etcd数据，确保在灾难发生时能够恢复集群状态。

### 3.3 Scheduler

- 功能：根据资源需求和调度策略，将Pod分配到合适的Node上。
- 调度算法：考虑资源利用率、亲和性/反亲和性、污点和容忍等因素。
- 扩展性：支持自定义调度器和调度插件，满足特定的调度需求。

### 3.4 Controller Manager

- 功能：运行各种控制器，确保集群的期望状态与实际状态一致。

- 常见控制器：
  - ReplicaSet Controller：管理Pod的副本数量。
  - Deployment Controller：管理Deployment资源，支持滚动更新和回滚。
  - Node Controller：监控Node的状态，处理Node故障。
  - Endpoint Controller：管理Service的Endpoints，确保服务发现的准确性。

### 3.5 Kubelet

- 功能：每个Node上运行的代理，负责Pod和容器的生命周期管理。
- 任务：确保Pod按照定义运行，监控容器状态，报告Node状态。
- 交互：与API Server通信，接收调度指令和更新信息。

### 3.6 Kube-Proxy

- 功能：实现Kubernetes的网络服务，管理Service的负载均衡和网络路由。
- 工作方式：基于iptables或IPVS，转发流量到对应的Pod。
- 高可用性：在多个Node上运行，确保网络服务的可靠性。

### 3.7 案例分析

案例1：API Server的高可用性配置

```txt
背景：一个生产环境的Kubernetes集群需要确保API Server的高可用性，避免单点故障影响整个集群。

解决方案：
多实例部署：在多个控制平面节点上部署多个API Server实例。
负载均衡器：使用外部负载均衡器（如HAProxy、Nginx）分发API请求到各个API Server实例。
etcd集群：部署etcd集群，确保数据的高可用性和一致性。
证书管理：配置安全证书，确保API Server通信的安全性。
```

案例2：etcd数据备份与恢复

```txt
背景：为了防止etcd数据丢失或损坏，需定期备份etcd数据，并能够在必要时进行恢复。
步骤：

备份etcd数据：
ETCDCTL_API=3 etcdctl snapshot save /path/to/backup.db \
 --endpoints=https://127.0.0.1:2379 \
 --cacert=/etc/kubernetes/pki/etcd/ca.crt \
 --cert=/etc/kubernetes/pki/etcd/server.crt \
 --key=/etc/kubernetes/pki/etcd/server.key

恢复etcd数据：
ETCDCTL_API=3 etcdctl snapshot restore /path/to/backup.db \
 --data-dir=/var/lib/etcd-new \
 --initial-cluster=<cluster> \
 --initial-cluster-token=<token> \
 --initial-advertise-peer-urls=https://<new-etcd-peer-url>

验证恢复：
启动新的etcd实例，确保数据一致性。
检查集群状态，确认所有组件正常运行。
```

案例3：Scheduler自定义调度策略

```txt
背景：某应用需要Pod部署到具有特定标签的Node上，例如仅在高性能GPU节点上运行。

解决方案：
Node标签：为GPU节点添加标签，例如gpu=true。
kubectl label nodes <node-name> gpu=true

Deployment配置：在Pod的调度策略中指定节点选择器。
spec:
 containers:
  - name: gpu-app
    image: gpu-app:latest
    nodeSelector:
    gpu: "true"

应用Deployment：
kubectl apply -f gpu-deployment.yaml

验证：确保Pod被调度到带有gpu=true标签的Node上。
```



## 4. 搭建Kubernetes集群环境

### 4.1 Minikube介绍

Minikube是一个轻量级的本地Kubernetes集群，适用于开发和学习环境。它支持多种虚拟化驱动（如VirtualBox、Docker），易于安装和启动。

### 4.2 安装前准备

系统要求：确保操作系统支持虚拟化，安装了合适的虚拟化引擎。

依赖工具：

* `kubectl`：Kubernetes命令行工具，用于与集群交互。

虚拟化软件：如VirtualBox、Docker Desktop（MacOS/Windows）。

### 4.3 安装Minikube

根据不同的操作系统，Minikube的安装步骤有所不同。

#### 4.3.1 在Windows上安装Minikube

安装Chocolatey（如果未安装）：

```powershell
Set-ExecutionPolicy Bypass -Scope Process -Force; `
[System.Net.ServicePointManager]::SecurityProtocol = `
[System.Net.ServicePointManager]::SecurityProtocol -bor 3072; `
iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
```

使用Chocolatey安装Minikube：

```powershell
choco install minikube
```

验证安装：

```powershell
minikube version
```



#### 4.3.2 在MacOS上安装Minikube

安装Homebrew（如果未安装）：

```bash
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
```

使用Homebrew安装Minikube：

```bash
brew install minikube
```

验证安装：

```bash
minikube version
```



#### 4.3.3 在Linux上安装Minikube

下载Minikube二进制文件：

```bash
curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
sudo mv minikube /usr/local/bin/
sudo chmod +x /usr/local/bin/minikube
```

验证安装：

```bash
minikube version
```



### 4.4 启动Minikube集群

基本启动命令：

```bash
minikube start
```

指定Kubernetes版本：

```bash
minikube start --kubernetes-version=v1.26.0
```

指定虚拟化驱动：

```bash
minikube start --driver=virtualbox
```

常见启动参数：

```txt
--cpus：分配给集群的CPU数量。
--memory：分配给集群的内存大小。
--disk-size：分配给集群的磁盘空间。
```



### 4.5 验证集群状态

检查节点状态：

```bash
kubectl get nodes
```

预期输出：

```txt
NAME       STATUS   ROLES    AGE   VERSION
minikube   Ready    master   5m    v1.26.0
```

查看所有命名空间中的Pod：

```bash
kubectl get pods --all-namespaces
#预期输出
NAMESPACE     NAME                                       READY   STATUS    RESTARTS   AGE
kube-system   coredns-<hash>                             1/1     Running   0          5m
kube-system   etcd-minikube                              1/1     Running   0          5m
kube-system   kube-apiserver-minikube                    1/1     Running   0          5m
kube-system   kube-controller-manager-minikube           1/1     Running   0          5m
kube-system   kube-scheduler-minikube                    1/1     Running   0          5m
kube-system   storage-provisioner                        1/1     Running   0          5m
```

检查Kubernetes版本：

```bash
kubectl version --short
#预期输出
Client Version: v1.26.0
Server Version: v1.26.0
```




### 4.6 案例分析

案例1：在MacOS上使用Minikube搭建Kubernetes集群

```txxt
步骤：
安装Homebrew（如果未安装）：
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

使用Homebrew安装Minikube：
brew install minikube

启动Minikube集群：
minikube start --driver=hyperkit --memory=4096 --cpus=2

验证集群状态：
kubectl get nodes

常见问题解决：
启动失败：检查Hyperkit是否正确安装，使用以下命令安装：
brew install hyperkit

资源不足：调整内存和CPU分配，确保主机有足够资源运行Minikube。
```

案例2：在Linux上使用Minikube搭建集群并配置虚拟化驱动

```txt
步骤：
安装Minikube：
curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
sudo mv minikube /usr/local/bin/
sudo chmod +x /usr/local/bin/minikube

安装KVM2驱动（推荐用于Linux）：
sudo apt-get update
sudo apt-get install -y qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils
sudo adduser $USER libvirt
newgrp libvirt

启动Minikube集群：
minikube start --driver=kvm2 --memory=4096 --cpus=2

验证集群状态：
kubectl get nodes

常见问题解决：
权限问题：确保用户属于libvirt组，重新登录或使用newgrp libvirt。
KVM未启动：启动libvirt服务：
sudo systemctl start libvirtd

```

案例3：在Windows上使用Minikube搭建集群

```txt
步骤：
安装Chocolatey（如果未安装）：
Set-ExecutionPolicy Bypass -Scope Process -Force; `
[System.Net.ServicePointManager]::SecurityProtocol = `
[System.Net.ServicePointManager]::SecurityProtocol -bor 3072; `
iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))

使用Chocolatey安装Minikube：
choco install minikube

安装VirtualBox（如果使用VirtualBox驱动）：
choco install virtualbox

启动Minikube集群：
minikube start --driver=virtualbox --memory=4096 --cpus=2

验证集群状态：
kubectl get nodes

常见问题解决：
VirtualBox未安装：确保VirtualBox已正确安装，重新启动计算机后再尝试启动Minikube。
网络配置问题：检查VirtualBox网络设置，确保网络适配器配置正确。
```



## 5. Kubernetes基础资源与对象

### 5.1 Pod

Pod是Kubernetes中最小的可部署单元，一个Pod可以包含一个或多个紧密关联的容器。

#### 5.1.1 编写Pod YAML文件

创建一个名为nginx-pod.yaml的文件，内容如下：

apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
  labels:
    app: nginx
spec:
  containers:

  - name: nginx
    image: nginx:latest
    ports:
    - containerPort: 80
AI写代码
yaml

1
2
3
4
5
6
7
8
9
10
11
12
文件说明：

apiVersion: v1：指定资源的API版本。
kind: Pod：指定资源类型为Pod。
metadata：
name: nginx-pod：Pod的名称。
labels：用于标识Pod的标签，便于选择和管理。
spec：
containers：定义Pod内的容器列表。
name: nginx：容器的名称。
image: nginx:latest：容器使用的镜像。
ports：容器监听的端口。
5.1.2 应用Pod配置
在终端中运行以下命令，将Pod部署到Kubernetes集群中：

kubectl apply -f nginx-pod.yaml
AI写代码
bash
1
预期输出：

pod/nginx-pod created
AI写代码
1
5.1.3 验证Pod状态
运行以下命令查看Pod的状态：

kubectl get pods
AI写代码
bash
1
预期输出：

NAME         READY   STATUS    RESTARTS   AGE
nginx-pod    1/1     Running   0          2m
AI写代码
1
2
5.1.4 查看Pod详细信息
运行以下命令查看Pod的详细信息，包括事件日志：

kubectl describe pod nginx-pod
AI写代码
bash
1
重点信息：

Containers部分：确认容器已启动并监听80端口。
Events部分：检查是否有错误或警告。
5.2 Deployment
Deployment是Kubernetes中的一种控制器，用于管理Pod的部署和更新，支持滚动更新和回滚。

5.2.1 编写Deployment YAML文件
创建一个名为nginx-deployment.yaml的文件，内容如下：

apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 2
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80
AI写代码
yaml

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
文件说明：

apiVersion: apps/v1：指定资源的API版本。
kind: Deployment：指定资源类型为Deployment。
metadata：
name: nginx-deployment：Deployment的名称。
labels：用于标识Deployment的标签。
spec：
replicas: 2：指定运行的Pod副本数量。
selector：
matchLabels：指定选择器标签，匹配Pod的标签。
template：
metadata：
labels：Pod的标签，需与选择器匹配。
spec：
containers：定义Pod内的容器列表。
5.2.2 应用Deployment配置
运行以下命令，将Deployment部署到Kubernetes集群中：

kubectl apply -f nginx-deployment.yaml
AI写代码
bash
1
预期输出：

deployment.apps/nginx-deployment created
AI写代码
1
5.2.3 验证Deployment状态
运行以下命令查看Deployment的状态：

kubectl get deployments
AI写代码
bash
1
预期输出：

NAME                READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment    2/2     2            2           5m
AI写代码
1
2
5.2.4 查看Pods状态
运行以下命令查看由Deployment管理的Pods状态：

kubectl get pods
AI写代码
bash
1
预期输出：

NAME                                READY   STATUS    RESTARTS   AGE
nginx-deployment-7c8d9b6c6d-abcde   1/1     Running   0          5m
nginx-deployment-7c8d9b6c6d-fghij   1/1     Running   0          5m
AI写代码
1
2
3
5.2.5 扩展Deployment副本数
运行以下命令将Deployment的副本数扩展到3个：

kubectl scale deployment nginx-deployment --replicas=3
AI写代码
bash
1
预期输出：

deployment.apps/nginx-deployment scaled
AI写代码
1
5.2.6 滚动更新Deployment
假设需要将Nginx镜像从nginx:latest更新到nginx:1.19，确保服务的连续性。

修改Deployment YAML文件：

将image: nginx:latest修改为image: nginx:1.19。

containers:
- name: nginx
  image: nginx:1.19
  ports:
  - containerPort: 80
AI写代码
yaml
1
2
3
4
5
应用更新：

kubectl apply -f nginx-deployment.yaml
AI写代码
bash
1
监控滚动更新进度：

kubectl rollout status deployment nginx-deployment
AI写代码
bash
1
预期输出：

deployment "nginx-deployment" successfully rolled out
AI写代码
1
验证更新：

kubectl get pods -l app=nginx
AI写代码
bash
1
确认所有Pod已使用新的Nginx版本。
回滚Deployment（如有需要）：

kubectl rollout undo deployment nginx-deployment
AI写代码
bash
1
预期输出：

deployment.apps/nginx-deployment rolled back
AI写代码
1
5.2.7 回滚Deployment
如果更新失败或出现问题，可以通过以下命令回滚到之前的稳定版本：

kubectl rollout undo deployment nginx-deployment
AI写代码
bash
1
预期输出：

deployment.apps/nginx-deployment rolled back
AI写代码
1
验证回滚：

kubectl get pods -l app=nginx
AI写代码
bash
1
确认所有Pod已回滚到旧的镜像版本。
5.3 Service
Service定义了一组Pod的访问策略，提供稳定的网络访问和负载均衡。

5.3.1 编写Service YAML文件
创建一个名为nginx-service.yaml的文件，内容如下：

apiVersion: v1
kind: Service
metadata:
  name: nginx-service
  labels:
    app: nginx
spec:
  type: NodePort
  selector:
    app: nginx
  ports:
  - port: 80
    targetPort: 80
    nodePort: 30007
AI写代码
yaml

1
2
3
4
5
6
7
8
9
10
11
12
13
14
文件说明：

apiVersion: v1：指定资源的API版本。
kind: Service：指定资源类型为Service。
metadata：
name: nginx-service：Service的名称。
labels：用于标识Service的标签。
spec：
type: NodePort：指定Service的类型为NodePort。
selector：
app: nginx：选择标签为app: nginx的Pod。
ports：
port: 80：Service的端口。
targetPort: 80：Pod容器的端口。
nodePort: 30007：主机端口，通过该端口可以访问Service。
5.3.2 应用Service配置
运行以下命令，将Service部署到Kubernetes集群中：

kubectl apply -f nginx-service.yaml
AI写代码
bash
1
预期输出：

service/nginx-service created
AI写代码
1
5.3.3 验证Service状态
运行以下命令查看Service的状态：

kubectl get svc nginx-service
AI写代码
bash
1
预期输出：

NAME            TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE
nginx-service   NodePort    10.96.0.1       <none>        80:30007/TCP   5m
AI写代码
1
2
5.3.4 访问Nginx应用
获取Minikube的IP地址（如果使用Minikube）：

minikube ip
AI写代码
bash
1
预期输出：
192.168.99.100
AI写代码
1
在浏览器中输入访问URL：

http://192.168.99.100:30007
AI写代码
1
应显示Nginx欢迎页面，表示Service已成功暴露应用。
5.3.5 Service类型详解
ClusterIP（默认）：

描述：仅在集群内部可访问。
用途：内部通信，如服务间调用。
NodePort：

描述：在每个Node的固定端口上暴露服务。
用途：开发和测试环境，或外部访问有限的服务。
LoadBalancer：

描述：通过云提供商的负载均衡器暴露服务，分配一个外部IP。
用途：生产环境，提供高可用性和负载均衡。
ExternalName：

描述：将Service映射到外部DNS名称。
用途：访问集群外部资源，简化DNS管理。
5.4 Namespace
Namespace用于在同一个集群中划分多个虚拟子集，便于资源隔离和管理。

5.4.1 创建Namespace
运行以下命令创建一个名为dev的Namespace：

kubectl create namespace dev
AI写代码
bash
1
验证创建：

kubectl get namespaces
AI写代码
bash
1
预期输出：

NAME              STATUS   AGE
default           Active   10m
kube-node-lease   Active   10m
kube-public       Active   10m
kube-system       Active   10m
dev               Active   2m
AI写代码
1
2
3
4
5
6
5.4.2 在Namespace中部署应用
将之前编写的nginx-pod.yaml部署到dev Namespace中：

kubectl apply -f nginx-pod.yaml -n dev
AI写代码
bash
1
验证Pod在dev Namespace中运行：

kubectl get pods -n dev
AI写代码
bash
1
预期输出：

NAME        READY   STATUS    RESTARTS   AGE
nginx-pod   1/1     Running   0          1m
AI写代码
1
2
5.4.3 资源隔离验证
创建另一个Namespace（如prod）：

kubectl create namespace prod
AI写代码
bash
1
在prod Namespace中部署不同的Pod：

kubectl apply -f nginx-pod.yaml -n prod
AI写代码
bash
1
查看所有Namespace中的Pod：

kubectl get pods --all-namespaces
AI写代码
bash
1
预期输出：
NAMESPACE     NAME        READY   STATUS    RESTARTS   AGE
default       nginx-pod   1/1     Running   0          10m
dev           nginx-pod   1/1     Running   0          5m
prod          nginx-pod   1/1     Running   0          2m
kube-system   ...
AI写代码
1
2
3
4
5
确认不同Namespace中的Pod相互独立。

5.5 ConfigMap与Secret
5.5.1 创建ConfigMap
ConfigMap用于存储非敏感的配置信息，如配置文件、环境变量。

编写ConfigMap YAML文件（app-configmap.yaml）：

apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  APP_ENV: production
  LOG_LEVEL: info
AI写代码
yaml
1
2
3
4
5
6
7
应用ConfigMap：

kubectl apply -f app-configmap.yaml
AI写代码
bash
1
5.5.2 创建Secret
Secret用于存储敏感信息，如密码、API密钥、证书。

使用kubectl命令创建Secret：

kubectl create secret generic db-secret --from-literal=username=dbuser --from-literal=password=securepassword
AI写代码
bash
1
验证Secret创建：

kubectl get secrets
AI写代码
bash
1
预期输出：
NAME          TYPE                                  DATA   AGE
db-secret     Opaque                                2      5m
app-config    Opaque                                2      5m
AI写代码
1
2
3
5.5.3 在Pod中使用ConfigMap和Secret
编写Pod YAML文件（app-pod.yaml）：

apiVersion: v1
kind: Pod
metadata:
  name: app-pod
spec:
  containers:
  - name: app-container
    image: myapp:latest
    env:
    - name: APP_ENV
      valueFrom:
        configMapKeyRef:
          name: app-config
          key: APP_ENV
    - name: LOG_LEVEL
      valueFrom:
        configMapKeyRef:
          name: app-config
          key: LOG_LEVEL
    - name: DB_USERNAME
      valueFrom:
        secretKeyRef:
          name: db-secret
          key: username
    - name: DB_PASSWORD
      valueFrom:
        secretKeyRef:
          name: db-secret
          key: password
AI写代码
yaml

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
部署Pod：

kubectl apply -f app-pod.yaml
AI写代码
bash
1
验证环境变量：

kubectl exec -it app-pod -- env | grep APP_ENV
kubectl exec -it app-pod -- env | grep DB_PASSWORD
AI写代码
bash
1
2
预期输出：
APP_ENV=production
DB_PASSWORD=securepassword
AI写代码
1
2
5.6 案例分析
案例1：创建并管理Pod
场景：开发者需要在集群中运行一个简单的Nginx服务器，快速验证Kubernetes集群的功能。
步骤：
编写Pod YAML文件（nginx-pod.yaml）：
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
spec:
  containers:
  - name: nginx
    image: nginx:latest
    ports:
    - containerPort: 80
AI写代码
yaml

1
2
3
4
5
6
7
8
9
10
部署Pod：
kubectl apply -f nginx-pod.yaml
AI写代码
bash
1
查看Pod状态：
kubectl get pods
AI写代码
bash
1
预期输出：
NAME        READY   STATUS    RESTARTS   AGE
nginx-pod   1/1     Running   0          2m
AI写代码
1
2
查看Pod详细信息：
kubectl describe pod nginx-pod
AI写代码
bash
1
重点信息：
Containers部分，确认容器已启动并监听80端口。
Events部分，检查是否有错误或警告。
案例2：创建并管理Deployment
场景：运维团队需要部署一个高可用的Nginx应用，确保在Pod故障时自动重建，并支持版本更新。
步骤：
编写Deployment YAML文件（nginx-deployment.yaml）：
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80
AI写代码
yaml

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
部署Deployment：
kubectl apply -f nginx-deployment.yaml
AI写代码
bash
1
查看Deployment状态：
kubectl get deployments
AI写代码
bash
1
预期输出：
NAME               READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   2/2     2            2           5m
AI写代码
1
2
查看Pods状态：
kubectl get pods
AI写代码
bash
1
预期输出：
NAME                                READY   STATUS    RESTARTS   AGE
nginx-deployment-7c8d9b6c6d-abcde   1/1     Running   0          5m
nginx-deployment-7c8d9b6c6d-fghij   1/1     Running   0          5m
AI写代码
1
2
3
扩展Deployment副本数：
kubectl scale deployment nginx-deployment --replicas=3
AI写代码
bash
1
验证扩展：
kubectl get deployments
AI写代码
bash
1
预期输出：
NAME                READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment    3/3     3            3           10m
AI写代码
1
2
滚动更新Deployment：
修改镜像版本：将Nginx版本升级到1.19。
更新YAML文件：
containers:
- name: nginx
  image: nginx:1.19
  ports:
  - containerPort: 80
AI写代码
yaml
1
2
3
4
5
应用更新：
kubectl apply -f nginx-deployment.yaml
AI写代码
bash
1
监控更新进度：
kubectl rollout status deployment nginx-deployment
AI写代码
bash
1
预期输出：
deployment "nginx-deployment" successfully rolled out
AI写代码
1
验证更新：
kubectl get pods -l app=nginx
AI写代码
bash
1
确认所有Pod已使用新的Nginx版本。
回滚Deployment（如有需要）：
kubectl rollout undo deployment nginx-deployment
AI写代码
bash
1
监控回滚进度：
kubectl rollout status deployment nginx-deployment
AI写代码
bash
1
预期输出：
deployment "nginx-deployment" successfully rolled out
AI写代码
1
验证回滚：
kubectl get pods -l app=nginx
AI写代码
bash
1
确认所有Pod已回滚到旧的镜像版本。
案例3：创建并管理Namespace
场景：开发团队需要在集群中创建一个名为dev的Namespace，用于开发环境的资源隔离。
步骤：
创建dev Namespace：
kubectl create namespace dev
AI写代码
bash
1
验证Namespace创建：
kubectl get namespaces
AI写代码
bash
1
预期输出：
NAME              STATUS   AGE
default           Active   10m
kube-node-lease   Active   10m
kube-public       Active   10m
kube-system       Active   10m
dev               Active   2m
AI写代码
1
2
3
4
5
6
在dev Namespace中部署Pod：
kubectl apply -f nginx-pod.yaml -n dev
AI写代码
bash
1
查看dev Namespace中的Pod：
kubectl get pods -n dev
AI写代码
bash
1
预期输出：
NAME        READY   STATUS    RESTARTS   AGE
nginx-pod   1/1     Running   0          1m
AI写代码
1
2
资源隔离验证：
创建另一个Namespace（如prod）：
kubectl create namespace prod
AI写代码
bash
1
在prod Namespace中部署不同的Pod：
kubectl apply -f nginx-pod.yaml -n prod
AI写代码
bash
1
查看所有Namespace中的Pod：
kubectl get pods --all-namespaces
AI写代码
bash
1
预期输出：
NAMESPACE     NAME        READY   STATUS    RESTARTS   AGE
default       nginx-pod   1/1     Running   0          10m
dev           nginx-pod   1/1     Running   0          5m
prod          nginx-pod   1/1     Running   0          2m
kube-system   ...
AI写代码
1
2
3
4
5
确认不同Namespace中的Pod相互独立。
案例4：使用ConfigMap和Secret管理配置
场景：应用程序需要从外部配置文件读取配置信息，并使用数据库密码等敏感信息。
步骤：
创建ConfigMap：
编写ConfigMap YAML文件（app-configmap.yaml）：
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  APP_ENV: production
  LOG_LEVEL: info
AI写代码
yaml
1
2
3
4
5
6
7
应用ConfigMap：
kubectl apply -f app-configmap.yaml
AI写代码
bash
1
创建Secret：
使用kubectl命令创建Secret：
kubectl create secret generic db-secret --from-literal=username=dbuser --from-literal=password=securepassword
AI写代码
bash
1
验证Secret创建：
kubectl get secrets
AI写代码
bash
1
预期输出：
NAME          TYPE                                  DATA   AGE
db-secret     Opaque                                2      5m
app-config    Opaque                                2      5m
AI写代码
1
2
3
在Pod中使用ConfigMap和Secret：
编写Pod YAML文件（app-pod.yaml）：
apiVersion: v1
kind: Pod
metadata:
  name: app-pod
spec:
  containers:
  - name: app-container
    image: myapp:latest
    env:
    - name: APP_ENV
      valueFrom:
        configMapKeyRef:
          name: app-config
          key: APP_ENV
    - name: LOG_LEVEL
      valueFrom:
        configMapKeyRef:
          name: app-config
          key: LOG_LEVEL
    - name: DB_USERNAME
      valueFrom:
        secretKeyRef:
          name: db-secret
          key: username
    - name: DB_PASSWORD
      valueFrom:
        secretKeyRef:
          name: db-secret
          key: password
AI写代码
yaml

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
部署Pod：
kubectl apply -f app-pod.yaml
AI写代码
bash
1
验证环境变量：
kubectl exec -it app-pod -- env | grep APP_ENV
kubectl exec -it app-pod -- env | grep DB_PASSWORD
AI写代码
bash
1
2
预期输出：
APP_ENV=production
DB_PASSWORD=securepassword
AI写代码
1
2